<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ëŒ€í•™ì „ìŸ: ë¸”ë¡ ì˜¤ëª© (Legendary AI)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; background: #dfe4ea; font-family: 'Pretendard', sans-serif; user-select: none; -webkit-touch-callout: none; }
        #game-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; height: 100dvh; z-index: 1; touch-action: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; height: 100dvh; z-index: 10; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        .top-bar { pointer-events: auto; display: flex; gap: 10px; background: rgba(255,255,255,0.95); padding: 10px 15px; margin: 10px; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); align-items: flex-start; }
        .btn-home { background: #34495e; color: white; border: none; padding: 0 15px; border-radius: 8px; cursor: pointer; font-size: 0.9rem; font-weight: bold; display: flex; align-items: center; justify-content: center; height: 50px; letter-spacing: -0.5px; }
        
        .game-info-col { flex-grow: 1; display: flex; flex-direction: column; gap: 5px; }
        .row-upper { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        .row-lower { display: flex; justify-content: space-between; align-items: center; width: 100%; margin-top: 5px; }
        .title-row { display: flex; align-items: center; gap: 8px; font-size: 1.1rem; }
        
        .score-box { font-weight: bold; font-size: 0.9rem; display: flex; gap: 8px; align-items: center; }
        .player-info { display: flex; flex-direction: column; line-height: 1.1; }
        .p-name { font-size: 0.75rem; opacity: 0.8; }
        .p-score { font-size: 1rem; }
        .p1 { color: #e74c3c; } .p2 { color: #2ecc71; } 
        
        .btn { background: #fff; border: 1px solid #ccc; padding: 6px 10px; border-radius: 6px; cursor: pointer; font-size: 0.85rem; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.05); transition: all 0.2s; white-space: nowrap; }
        .btn:active { transform: translateY(1px); background: #f0f0f0; }
        .btn-hint { background: #f1c40f; border-color: #f39c12; color: #fff; }
        .btn-ai-toggle { background: #ecf0f1; color: #7f8c8d; }
        .btn-ai-toggle.active { background: #2ecc71; color: white; border-color: #27ae60; }
        .btn-resign { background: #e74c3c; color: white; border-color: #c0392b; }
        
        .phase-badge { font-size: 0.75rem; color: white; padding: 4px 8px; border-radius: 4px; background: #333; vertical-align: middle; }
        
        .ai-status-box { margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee; text-align: left; }
        #ai-status-text { font-size: 0.9rem; font-weight: bold; color: #e67e22; }
        .manual-upload { font-size: 0.8rem; color: #999; cursor: pointer; text-decoration: underline; margin-left: 10px; }

        .fab-rotate-container { position: absolute; right: 20px; bottom: 30px; display: flex; flex-direction: column; align-items: center; pointer-events: auto; }
        .fab-rotate { width: 70px; height: 70px; background: #fff; color: #333; border-radius: 50%; border: 2px solid #ddd; display: flex; justify-content: center; align-items: center; font-size: 2.2rem; cursor: pointer; box-shadow: 0 6px 15px rgba(0,0,0,0.2); transition: transform 0.1s; }
        .fab-rotate:active { transform: scale(0.95); background: #f9f9f9; }
        .key-hint { font-size: 0.7rem; color: #666; margin-top: 5px; font-weight: bold; text-shadow: 1px 1px 0 #fff; }

        .fab-rules { pointer-events: auto; position: absolute; left: 20px; bottom: 30px; width: 45px; height: 45px; background: #3498db; color: white; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 1.2rem; cursor: pointer; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
        .log-panel { pointer-events: none; position: absolute; left: 20px; bottom: 85px; background: rgba(0,0,0,0.6); color: #fff; width: 250px; height: 120px; border-radius: 8px; padding: 10px; overflow: hidden; font-family: monospace; font-size: 0.8rem; display: flex; flex-direction: column-reverse; text-shadow: 1px 1px 2px black; }
        
        #lobby-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.95); z-index: 200; display: flex; flex-direction: column; justify-content: center; align-items: center; pointer-events: auto; }
        .lobby-box { text-align: center; background: white; padding: 40px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.15); width: 85%; max-width: 400px; }
        .lobby-title { font-size: 2rem; font-weight: bold; margin-bottom: 20px; color: #2c3e50; }
        .lobby-btn { width: 100%; padding: 15px; margin: 8px 0; font-size: 1.1rem; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; color: white; transition: transform 0.1s; }
        .btn-single { background: #9b59b6; } .btn-create { background: #3498db; } .btn-join { background: #2ecc71; }
        .lobby-input { width: 100%; padding: 12px; margin: 8px 0; font-size: 1.1rem; border: 2px solid #ddd; border-radius: 10px; box-sizing: border-box; text-align: center; }
        .code-input { letter-spacing: 2px; text-transform: uppercase; }
        
        #ai-loader { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 15px 30px; border-radius: 30px; font-weight: bold; font-size: 1.2rem; z-index: 50; pointer-events: none; backdrop-filter: blur(5px); }
        #my-player-badge { font-size: 0.8rem; font-weight: bold; padding: 4px 10px; border-radius: 15px; display: inline-block; color: white; }
        
        /* ğŸŒŸ ìŠ¹ë¥  ë°” ìŠ¤íƒ€ì¼ ìˆ˜ì • (í•­ìƒ ë³´ì´ë„ë¡) */
        #win-rate-bar-container { position: absolute; top: 130px; right: 10px; width: 12px; height: 150px; background: #ddd; border-radius: 6px; overflow: hidden; border: 1px solid #999; z-index: 5; pointer-events: none; display: none; }
        #win-rate-fill { width: 100%; height: 50%; background: linear-gradient(to top, #2c3e50, #4ca1af); transition: height 0.5s ease-out; position: absolute; bottom: 0; }
        #win-rate-text { position: absolute; top: 110px; right: 30px; font-size: 0.8rem; font-weight: bold; color: #333; text-align: right; width: 120px; text-shadow: 1px 1px 0 rgba(255,255,255,0.8); display: none; }

        .modal-overlay { pointer-events: auto; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: none; justify-content: center; align-items: center; z-index: 300; }
        .modal-content { background: white; width: 85%; max-width: 500px; max-height: 85%; border-radius: 12px; padding: 25px; overflow-y: auto; position: relative; text-align: center; }
        .close-btn { position: absolute; top: 15px; right: 20px; font-size: 1.5rem; cursor: pointer; color: #888; }
        h3 { margin-top: 0; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        .rule-sec { margin-bottom: 15px; text-align: left; } .rule-head { font-weight: bold; color: #2c3e50; margin-bottom: 5px; } .rule-desc { font-size: 0.9rem; color: #555; line-height: 1.5; }
        
        .end-btn-group { display: flex; flex-direction: column; gap: 10px; margin-top: 20px; }
        .req-btn { width: 48%; padding: 12px; font-weight: bold; border-radius: 8px; border: none; cursor: pointer; color: white; }
        .req-btn.yes { background: #2ecc71; } .req-btn.no { background: #e74c3c; }
    </style>
    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } } </script>
</head>
<body>
    <div id="lobby-overlay">
        <div class="lobby-box">
            <div class="lobby-title">ğŸ² ë¸”ë¡ ì˜¤ëª©</div>
            <div id="lobby-main">
                <input type="text" id="nickname-input" class="lobby-input" placeholder="ë‹‰ë„¤ì„ (ìµœëŒ€ 6ì)" maxlength="6" value="Player">
                <button class="lobby-btn btn-single" onclick="showSideSelection()">ğŸ‘¤ AIì™€ ëŒ€ê²° (ì‹±ê¸€)</button>
                <div style="margin: 15px 0; border-top: 1px solid #eee;"></div>
                <div style="font-size:0.9rem; color:#666; margin-bottom:5px;">ì˜¨ë¼ì¸ ë©€í‹°í”Œë ˆì´</div>
                <button class="lobby-btn btn-create" onclick="createRoom()">ë°© ë§Œë“¤ê¸° (Host)</button>
                <div style="margin: 5px 0; color: #888; font-size:0.8rem;">- ë˜ëŠ” -</div>
                <input type="text" id="room-code-input" class="lobby-input code-input" placeholder="ì½”ë“œ 6ìë¦¬" maxlength="6">
                <button class="lobby-btn btn-join" onclick="joinRoom()">ë°© ì°¸ê°€í•˜ê¸° (Join)</button>

                <div class="ai-status-box">
                    <span id="ai-status-text">â³ AI ì—”ì§„ ë¡œë”© ì¤‘...</span>
                    <label for="ai-file-input" class="manual-upload">[ìˆ˜ë™ ì—…ë¡œë“œ]</label>
                    <input type="file" id="ai-file-input" accept=".json" style="display:none;" onchange="loadCustomAI(this)">
                </div>
            </div>

            <div id="lobby-side" style="display:none;">
                <h3 style="margin-bottom:20px; color:#2c3e50;">ì§„ì˜ì„ ì„ íƒí•˜ì„¸ìš”</h3>
                <button class="lobby-btn" style="background:#333; color:white;" onclick="startSingleGame(1)">âš« í‘ëŒ (ì„ ê³µ)</button>
                <button class="lobby-btn" style="background:#eee; color:#333; border:1px solid #ccc;" onclick="startSingleGame(2)">âšª ë°±ëŒ (í›„ê³µ)</button>
                <button class="btn" onclick="location.reload()" style="margin-top:20px; width:100%;">ì·¨ì†Œ</button>
            </div>

            <div id="lobby-wait" style="display:none;">
                <div style="font-size:1.2rem; margin-bottom:15px;">ë°© ì½”ë“œ: <span id="display-room-code" style="color:#e74c3c; font-weight:bold; font-size:2rem; letter-spacing:3px;"></span></div>
                <div style="color:#555;">ì¹œêµ¬ì—ê²Œ ì´ ì½”ë“œë¥¼ ì•Œë ¤ì£¼ì„¸ìš”.</div>
                <div style="margin-top:30px;">â³ ì ‘ì† ëŒ€ê¸° ì¤‘...</div>
                <button class="btn" onclick="location.reload()" style="margin-top:20px; width:100%;">ì·¨ì†Œ</button>
            </div>
        </div>
    </div>

    <div id="game-canvas"></div>
    <div id="ai-loader">ğŸ¤– AI ìƒê°ì¤‘...</div>

    <div id="win-rate-bar-container"><div id="win-rate-fill"></div></div>
    <div id="win-rate-text">í‘ ìŠ¹ë¥ : 50%</div>

    <div id="ui-layer" style="display:none;">
        <div class="top-bar">
            <button class="btn-home" onclick="goHome()">í™ˆí™”ë©´</button>
            <div class="game-info-col">
                <div class="row-upper">
                    <div class="title-row"> <span style="font-weight:bold;">BLOCK OMOK</span> <span id="game-phase" class="phase-badge">ì°©ìˆ˜</span> </div>
                    <div class="btn-group"> 
                        <button class="btn" id="btn-undo" onclick="window.requestUndo()">â†©ï¸ ë¬´ë¥´ê¸°</button> 
                        <button class="btn" id="btn-reset" onclick="window.resetGame()">ğŸ”„ ì´ˆê¸°í™”</button> 
                        <button class="btn btn-resign" id="btn-resign" onclick="window.resign()" style="display:none;">ğŸ³ï¸ ê¸°ê¶Œ</button>
                    </div>
                </div>
                <div class="score-box"> 
                    <div class="player-info p1">
                        <span class="p-name" id="name-p1">í‘</span>
                        <span class="p-score">ë¸”ë¡: <span id="p1-cnt">4</span></span>
                    </div>
                    <span style="margin:0 2px; color:#ccc">|</span>
                    <div class="player-info p2">
                        <span class="p-name" id="name-p2">ë°±</span>
                        <span class="p-score">ë¸”ë¡: <span id="p2-cnt">4</span></span>
                    </div>
                    <span id="turn-indicator" style="font-size:0.8rem; margin-left:5px; color:#e74c3c; white-space:nowrap;">(í‘ ì°¨ë¡€)</span> 
                </div>
                <div class="row-lower">
                    <div id="my-player-badge">ì‹±ê¸€ ëª¨ë“œ</div>
                    <div style="display:flex; gap:5px;">
                        <button id="btn-ai-toggle" class="btn btn-ai-toggle" onclick="window.toggleAIMode()">ğŸ¤– AI ëŒ€ì „</button>
                        <button class="btn btn-hint" onclick="window.askAI()">ğŸ’¡ íŒíŠ¸</button>
                    </div>
                </div>
            </div>
        </div>
        <div class="log-panel" id="log-console">
            <div>ğŸ‘† í´ë¦­í•˜ì—¬ ì°©ìˆ˜/ì„ íƒ</div>
            <div>ğŸš€ ê²Œì„ ì‹œì‘!</div>
        </div>
        <div class="fab-rotate-container">
            <div class="fab-rotate" id="btn-rotate">â†»</div>
            <div class="key-hint">(Rí‚¤)</div>
        </div>
        <div class="fab-rules" onclick="document.getElementById('rule-modal').style.display='flex'">?</div>
    </div>

    <div id="rule-modal" class="modal-overlay" onclick="if(event.target===this) this.style.display='none'">
        <div class="modal-content" style="text-align:left;">
            <span class="close-btn" onclick="document.getElementById('rule-modal').style.display='none'">&times;</span>
            <h3>ğŸ“œ ê²Œì„ ê·œì¹™ ìƒì„¸</h3>
            <div class="rule-sec"><div class="rule-head">1. ìŠ¹ë¦¬ ì¡°ê±´</div><div class="rule-desc">ìœ„ì—ì„œ ë‚´ë ¤ë‹¤ë³´ì•˜ì„ ë•Œ(Top View), ìì‹ ì˜ ìƒ‰ê¹” ë¸”ë¡ 5ê°œê°€ ì—°ì†(ê°€ë¡œ, ì„¸ë¡œ, ëŒ€ê°ì„ )ë˜ë©´ ìŠ¹ë¦¬í•©ë‹ˆë‹¤.</div></div>
            <div class="rule-sec"><div class="rule-head">2. ì°©ìˆ˜ ê·œì¹™</div><div class="rule-desc">- <b>ì ‘ì§€/ì§€ì§€:</b> ë°”ë‹¥ì— ë‹¿ê±°ë‚˜ ì•„ë˜ì— ë¸”ë¡ì´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.<br>- <b>ê¸ˆì§€ êµ¬ì—­:</b> ê°ì 2í„´ ë™ì•ˆ ê·€í‰ì´ ì°©ìˆ˜ ê¸ˆì§€.</div></div>
            <div class="rule-sec"><div class="rule-head">3. ì´ë™ ë‹¨ê³„</div><div class="rule-desc">- ë¸”ë¡ 4ê°œë¥¼ ë‹¤ ì“°ë©´ ê¸°ì¡´ ë¸”ë¡ì„ ì˜®ê²¨ì•¼ í•©ë‹ˆë‹¤.<br>- ìœ„ì— ë‹¤ë¥¸ ë¸”ë¡ì´ ìˆìœ¼ë©´ ëª» ì˜®ê¹ë‹ˆë‹¤.</div></div>
        </div>
    </div>

    <div id="end-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="end-title">ê²Œì„ ì¢…ë£Œ</h3>
            <div id="end-msg" style="margin:20px 0; font-size:1.1rem;"></div>
            <div class="end-btn-group" id="end-btns"></div>
        </div>
    </div>

    <div id="req-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>ğŸ“© ìš”ì²­ ë„ì°©</h3>
            <div id="req-msg" style="margin:20px 0; font-size:1.1rem; line-height:1.5;"></div>
            <div style="display:flex; justify-content:space-between;">
                <button class="req-btn yes" id="btn-req-yes">â­• ìˆ˜ë½</button>
                <button class="req-btn no" id="btn-req-no">âŒ ê±°ì ˆ</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getDatabase, ref, set, onValue, update, get, child, remove } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

        const firebaseConfig = {
            apiKey: "AIzaSyC6I8D1aazjTGBJdwQ1iHsQYyHXWHf3_PU",
            authDomain: "omok-game-95008.firebaseapp.com",
            databaseURL: "https://omok-game-95008-default-rtdb.firebaseio.com",
            projectId: "omok-game-95008",
            storageBucket: "omok-game-95008.firebasestorage.app",
            messagingSenderId: "34601684939",
            appId: "1:34601684939:web:4ed1cc9a0c653d9783b04e",
            measurementId: "G-XHNPPYPNQT"
        };
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        let myRoomId = null;
        let myPlayerNum = 0; 
        let isOnline = false;
        let isSpectator = false;
        let myNickname = "Player";
        let neuralWeights = null;
        let p1Name = "í‘", p2Name = "ë°±";

        window.goHome = () => { if(confirm("ê²Œì„ì—ì„œ ë‚˜ê°€ì‹œê² ìŠµë‹ˆê¹Œ?")) { location.hash = ""; } };
        window.addEventListener('popstate', () => {
            const hash = location.hash;
            if(!hash) {
                document.getElementById('game-canvas').style.display='none';
                document.getElementById('ui-layer').style.display='none';
                document.getElementById('lobby-overlay').style.display='flex';
                document.getElementById('lobby-main').style.display='block';
                document.getElementById('lobby-side').style.display='none';
                document.getElementById('lobby-wait').style.display='none';
                document.getElementById('win-rate-bar-container').style.display='none';
                document.getElementById('win-rate-text').style.display='none';
                isOnline = false; isSpectator = false; logic.reset(); 
                myRoomId = null; myPlayerNum = 0;
            }
        });

        // ğŸŒŸ NeuralAI: AI í•µì‹¬ ì§€ëŠ¥ (ì—¬ê¸°ì„œ JSON íŒŒì¼ì´ ì—†ìœ¼ë©´ ì˜¤ë¥˜ë‚¨)
        // ğŸŒŸ NeuralAI í´ë˜ìŠ¤ ì „ì²´ë¥¼ ì´ê±¸ë¡œ ë®ì–´ì“°ê±°ë‚˜, getBestMove í•¨ìˆ˜ë§Œ êµì²´í•˜ì„¸ìš”.
        class NeuralAI {
            constructor(weights) { this.weights = weights; this.ready = true; }

            getBestMove(logic, player) {
                // 1. ì°©ìˆ˜(Placement) ë‹¨ê³„ì¼ ë•Œ: ê¸°ì¡´ ë¡œì§ ê·¸ëŒ€ë¡œ ì‚¬ìš©
                if (logic.phase === 'PLACEMENT') {
                    if (logic.blocksLeft[player] <= 0) return null;
                    return this.computeBestPlacement(logic, player);
                }

                // 2. ì´ë™(Movement) ë‹¨ê³„ì¼ ë•Œ: "ê°€ìƒìœ¼ë¡œ ë“¤ì–´ë³´ê³ (Pick) -> ì°©ìˆ˜(Place)" ì‹œë®¬ë ˆì´ì…˜
                else if (logic.phase === 'MOVEMENT') {
                    let bestScore = -Infinity;
                    let bestMove = null;

                    // ë‚´ ë¸”ë¡ë“¤ì„ ì°¾ëŠ”ë‹¤ (ê³ ì •ëœ ë¸”ë¡ ì œì™¸)
                    const myBlocks = logic.blocks.filter(b => b.player === player && !b.isFixed);

                    // ê° ë¸”ë¡ì„ í•˜ë‚˜ì”© ë“¤ì–´ë³¸ë‹¤
                    for (const block of myBlocks) {
                        // ë¸”ë¡ì„ ë“¤ ìˆ˜ ì—†ëŠ” ìƒíƒœ(ìœ„ì— ëˆ„ê°€ ìˆê±°ë‚˜)ë©´ íŒ¨ìŠ¤
                        if (!logic.canPick(block)) continue;

                        // [ì‹œë®¬ë ˆì´ì…˜] ê°€ìƒìœ¼ë¡œ ë¸”ë¡ ì œê±°
                        const tempLogic = logic.clone();
                        tempLogic.removeBlock(block.id);
                        // "ì´ ë¸”ë¡ì„ ë“¤ì—ˆë‹¤"ê³  ì„¤ì • (ì œìë¦¬ ì°©ìˆ˜ ë°©ì§€ ë“± ê·œì¹™ ì ìš© ìœ„í•´)
                        tempLogic.selectedBlockOriginalCells = block.cells;

                        // ì´ ìƒíƒœì—ì„œ AIì—ê²Œ "ì–´ë””ì— ë‘ëŠ” ê²Œ ì¢‹ì•„?"ë¼ê³  ë¬¼ì–´ë´„
                        // AIëŠ” logits(ëª¨ë“  ìœ„ì¹˜ì— ëŒ€í•œ ì ìˆ˜)ë¥¼ ë°˜í™˜í•¨
                        const logits = this.computeLogits(tempLogic, player);

                        // ìƒìœ„ 10ê°œì˜ ì¢‹ì€ ìˆ˜ë§Œ ì¶”ë ¤ì„œ ìœ íš¨ì„± ê²€ì‚¬ (ì†ë„ ìµœì í™”)
                        const topActions = logits
                            .map((score, idx) => ({ score, idx }))
                            .sort((a, b) => b.score - a.score)
                            .slice(0, 20); // ìƒìœ„ 20ê°œ í›„ë³´ë§Œ ê²€ì‚¬

                        for (const action of topActions) {
                            // ì ìˆ˜ê°€ í˜„ì¬ ì°¾ì€ ìµœì ìˆ˜ë³´ë‹¤ ë‚®ìœ¼ë©´ ë” ë³¼ í•„ìš” ì—†ìŒ
                            if (action.score <= bestScore) continue;

                            // AIê°€ ì¶”ì²œí•œ ìœ„ì¹˜(index)ë¥¼ ì¢Œí‘œë¡œ ë³€í™˜
                            const sh = action.idx % 8;
                            const px = Math.floor(action.idx / 8) % 5;
                            const py = Math.floor(Math.floor(action.idx / 8) / 5);
                            
                            // ê¸°ì € ì…€ ê³„ì‚°
                            let baseCells = getCellsFromBase(px, py, sh);
                            let validZFound = false;
                            let finalCells = null;

                            // ë°”ë‹¥ë¶€í„° ìŒ“ì•„ì˜¬ë¦¬ë©° ê°€ëŠ¥í•œ zì¶• ì°¾ê¸°
                            for (let dz = 0; dz < 5; dz++) {
                                const testCells = baseCells.map(c => ({ x: c.x, y: c.y, z: c.z + dz }));
                                if (testCells.some(c => c.z > 4)) break;

                                // ê·œì¹™ ìœ„ë°˜ì¸ì§€ ê²€ì‚¬ (ì´ë™ ê·œì¹™ ì ìš©)
                                const check = tempLogic.checkValidity(player, testCells, true, block.cells);
                                if (check.ok) {
                                    finalCells = testCells;
                                    validZFound = true;
                                    break; // ê°€ì¥ ë‚®ì€ ê³³ì— ë‘ 
                                }
                            }

                            // ìœ íš¨í•œ ìˆ˜ë¼ë©´ í›„ë³´ë¡œ ë“±ë¡
                            if (validZFound && finalCells) {
                                bestScore = action.score;
                                bestMove = {
                                    type: 'move',
                                    fromId: block.id, // ì´ ë¸”ë¡ì„ ì˜®ê¸´ë‹¤
                                    cells: finalCells,
                                    shapeIdx: sh
                                };
                            }
                        }
                    }
                    return bestMove; // ê°€ì¥ ë†’ì€ ì ìˆ˜ë¥¼ ë°›ì€ ì´ë™ ë°˜í™˜
                }
                return null;
            }

            // ğŸŒŸ AIì˜ íŒë‹¨(Logits)ì„ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜ (ê³µí†µ ì‚¬ìš©ì„ ìœ„í•´ ë¶„ë¦¬)
            computeLogits(logic, player) {
                const obs = [];
                const opp = player === 1 ? 2 : 1;
                // ë³´ë“œ ìƒíƒœ ì…ë ¥ (One-hot encoding)
                for(let z=0; z<5; z++) for(let y=0; y<5; y++) for(let x=0; x<5; x++) obs.push(logic.board[z][y][x] === player ? 1 : 0);
                for(let z=0; z<5; z++) for(let y=0; y<5; y++) for(let x=0; x<5; x++) obs.push(logic.board[z][y][x] === opp ? 1 : 0);
                
                // ì‹ ê²½ë§ ì—°ì‚°
                let h1 = this.matMul(obs, this.weights.fc0_w, this.weights.fc0_b).map(x => Math.tanh(x));
                let h2 = this.matMul(h1, this.weights.fc1_w, this.weights.fc1_b).map(x => Math.tanh(x));
                const logits = this.matMul(h2, this.weights.fc2_w, this.weights.fc2_b);
                return logits;
            }

            // ê¸°ì¡´ ì°©ìˆ˜ ë¡œì§ (í•¨ìˆ˜ë¡œ ë¶„ë¦¬í•¨)
            computeBestPlacement(logic, player) {
                const logits = this.computeLogits(logic, player);
                const validActions = [];
                const actionToMove = {};

                // ëª¨ë“  ê°€ëŠ¥í•œ ì°©ìˆ˜ ìœ„ì¹˜ ë¯¸ë¦¬ ê³„ì‚°
                for(let i=0; i<200; i++) {
                    const sh = i % 8; const px = Math.floor(i / 8) % 5; const py = Math.floor(Math.floor(i / 8) / 5); 
                    let baseCells = getCellsFromBase(px, py, sh); 
                    let validZFound = false; let finalCells = null;
                    for (let dz = 0; dz < 5; dz++) {
                        const testCells = baseCells.map(c => ({ x: c.x, y: c.y, z: c.z + dz }));
                        if (testCells.some(c => c.z > 4)) break;
                        const check = logic.checkValidity(player, testCells);
                        if (check.ok) { finalCells = testCells; validZFound = true; break; }
                    }
                    if (validZFound && finalCells) { validActions.push(i); actionToMove[i] = { type: 'place', cells: finalCells, shapeIdx: sh }; }
                }

                if (validActions.length === 0) return null;
                let bestIdx = -1; let maxVal = -Infinity;
                for (let idx of validActions) { if (logits[idx] > maxVal) { maxVal = logits[idx]; bestIdx = idx; } }
                return bestIdx !== -1 ? actionToMove[bestIdx] : null;
            }

            matMul(input, w, b) {
                const output = new Array(b.length).fill(0);
                for (let j = 0; j < b.length; j++) { let sum = b[j]; for (let i = 0; i < input.length; i++) { sum += input[i] * w[j][i]; } output[j] = sum; }
                return output;
            }
        }

        // ğŸŒŸ MCTSAI: AIì˜ ìˆ˜ì½ê¸° ì—”ì§„ (ì´ì „ë³´ë‹¤ ì§€ëŠ¥ ìƒí–¥)
        class MCTSAI {
            constructor() { this.ready = true; }
            async getBestMove(logic, player, iterations = 1500, onThinkingCallback = null) {
                const validMoves = getAllValidMoves(logic, player);
                if (validMoves.length === 0) return null;
                
                // 1. í‚¬ê° (ì¦‰ì‹œ ìŠ¹ë¦¬) ë°œê²¬ ì‹œ ë°”ë¡œ ë‘ 
                for (let move of validMoves) if (this.simulateOneMove(logic, player, move) === player) return move;
                
                // 2. ë°©ì–´ (ìƒëŒ€ í‚¬ê°) ë°œê²¬ ì‹œ ë°”ë¡œ ë§‰ìŒ
                const opponent = player === 1 ? 2 : 1; 
                const myState = logic.clone(); 
                const oppMoves = getAllValidMoves(myState, opponent); 
                const threatMoves = [];
                for (let opMove of oppMoves) {
                    if (this.simulateOneMove(myState, opponent, opMove) === opponent) threatMoves.push(opMove);
                }
                if (threatMoves.length > 0) {
                    // ë°©ì–´ ê°€ëŠ¥í•œ ìˆ˜ ì°¾ê¸°
                    for (let myMove of validMoves) {
                        const testState = logic.clone(); 
                        this.applyMove(testState, player, myMove); 
                        let safe = true; 
                        const nextOppMoves = getAllValidMoves(testState, opponent);
                        for (let nom of nextOppMoves) {
                            if (this.simulateOneMove(testState, opponent, nom) === opponent) { safe = false; break; }
                        }
                        if (safe) return myMove; // ë°©ì–´ ì„±ê³µ
                    }
                }

                // 3. ì‹ ê²½ë§ (JSON íŒŒì¼ì´ ìˆìœ¼ë©´ ì‚¬ìš©)
                if (neuralWeights && logic.phase !== 'MOVEMENT') {
                    try { 
                        const brain = new NeuralAI(neuralWeights); 
                        const neuralMove = brain.getBestMove(logic, player); 
                        if (neuralMove) { 
                            if (onThinkingCallback) onThinkingCallback(neuralMove); 
                            await new Promise(r => setTimeout(r, 500)); 
                            return neuralMove; 
                        } 
                    } catch (e) { console.error("Neural Fail", e); }
                }

                // 4. MCTS ì‹œë®¬ë ˆì´ì…˜ (ìµœí›„ì˜ ìˆ˜ë‹¨) - ì‹œê°„ ì œí•œì„ ë„‰ë„‰íˆ ë‘ 
                const root = { state: logic.clone(), player: player, parent: null, children: [], visits: 0, wins: 0, move: null };
                const start = Date.now(); 
                let lastYield = Date.now();
                // ìƒê° ì‹œê°„ì„ ëŠ˜ë¦¼ (ìµœëŒ€ 2.5ì´ˆ)
                while ((Date.now() - start < 2500) || iterations > 0) {
                    if (Date.now() - lastYield > 30) {
                        // ì‹œê°í™” ì—…ë°ì´íŠ¸
                        let currentBestNode = null; let maxV = -1;
                        if(root.children.length > 0) for(let c of root.children) if(c.visits > maxV) { maxV = c.visits; currentBestNode = c; }
                        if (onThinkingCallback && currentBestNode && currentBestNode.move) onThinkingCallback(currentBestNode.move);
                        await new Promise(r => setTimeout(r, 0)); lastYield = Date.now();
                    }
                    let node = this.select(root);
                    if (!node.state.winner && node.visits > 0) node = this.expand(node);
                    const winner = this.simulateHeavy(node.state, node.player);
                    this.backpropagate(node, winner); 
                    iterations--; 
                    if (Date.now() - start > 5000) break; // ìµœëŒ€ 5ì´ˆ ê°•ì œ ì¢…ë£Œ
                }
                let bestChild = null; let maxVisits = -1;
                for (const child of root.children) { if (child.visits > maxVisits) { maxVisits = child.visits; bestChild = child; } }
                return bestChild ? bestChild.move : validMoves[0];
            }
            // ìŠ¹ë¥  ë¶„ì„ìš© (ë¹ ë¥´ê²Œ 500íŒ)
            getWinRate(logic, player, iterations = 500) {
                const root = { state: logic.clone(), player: player, parent: null, children: [], visits: 0, wins: 0, move: null };
                const start = Date.now();
                while (iterations > 0 && Date.now() - start < 500) {
                    let node = this.select(root); 
                    if (!node.state.winner && node.visits > 0) node = this.expand(node);
                    const winner = this.simulateHeavy(node.state, node.player); 
                    this.backpropagate(node, winner); 
                    iterations--;
                }
                if (root.visits === 0) return 50;
                return Math.max(0, Math.min(100, (root.wins / root.visits) * 100));
            }
            select(node) { while (node.children.length > 0) { node = node.children.reduce((best, child) => { const ucb1 = (child.wins / (child.visits + 1e-6)) + 1.41 * Math.sqrt(Math.log(node.visits + 1) / (child.visits + 1e-6)); const bestUcb1 = (best.wins / (best.visits + 1e-6)) + 1.41 * Math.sqrt(Math.log(node.visits + 1) / (best.visits + 1e-6)); return ucb1 > bestUcb1 ? child : best; }); } return node; }
            expand(node) { const moves = getAllValidMoves(node.state, node.player); for (const move of moves) { const newState = node.state.clone(); this.applyMove(newState, node.player, move); node.children.push({ state: newState, player: newState.currentPlayer, parent: node, children: [], visits: 0, wins: 0, move: move }); } return node.children.length > 0 ? node.children[Math.floor(Math.random() * node.children.length)] : node; }
            backpropagate(node, winner) { while (node) { node.visits++; if (winner !== 0) { if (node.parent && node.parent.player === winner) node.wins++; else if (node.parent && node.parent.player !== winner) node.wins -= 10; } node = node.parent; } }
            applyMove(state, player, move) { if (move.type === 'place') { state.addBlock(player, move.cells, move.shapeIdx); state.blocksLeft[player]--; } else { const b = state.blocks.find(x => x.id === move.fromId); if (b) { state.removeBlock(b.id); state.addBlock(player, move.cells, move.shapeIdx); } } state.winner = state.checkWin(); if (state.winner === 0) { state.currentPlayer = state.currentPlayer === 1 ? 2 : 1; if (state.blocksLeft[1]===0 && state.blocksLeft[2]===0) state.phase='MOVEMENT'; else if (state.blocksLeft[state.currentPlayer]===0 && state.phase==='PLACEMENT') state.phase='MOVEMENT'; } }
            simulateOneMove(logic, player, move) { const tempState = logic.clone(); this.applyMove(tempState, player, move); return tempState.winner; }
            simulateHeavy(state, player) { 
                let tempState = state.clone(); let depth = 0; 
                while (tempState.winner === 0 && depth < 30) { 
                    const currentPlayer = tempState.currentPlayer; 
                    const moves = getAllValidMoves(tempState, currentPlayer); 
                    if (moves.length === 0) break; 
                    let chosenMove = null; 
                    // ìŠ¤ë§ˆíŠ¸ ì‹œë®¬ë ˆì´ì…˜: ì´ê¸°ëŠ” ìˆ˜ê°€ ìˆìœ¼ë©´ ë°”ë¡œ ë‘”ë‹¤
                    for (let i = 0; i < moves.length; i++) { 
                        if (moves.length > 20 && i > 10 && Math.random() > 0.4) continue; 
                        if (this.simulateOneMove(tempState, currentPlayer, moves[i]) === currentPlayer) { chosenMove = moves[i]; break; } 
                    } 
                    if (!chosenMove) chosenMove = moves[Math.floor(Math.random() * moves.length)]; 
                    this.applyMove(tempState, currentPlayer, chosenMove); 
                    depth++; 
                } 
                return tempState.winner; 
            }
        }

        const SHAPES = [
            [{x:0,y:0,z:0}, {x:1,y:0,z:0}, {x:0,y:1,z:0}], [{x:0,y:0,z:0}, {x:1,y:0,z:0}, {x:0,y:-1,z:0}],
            [{x:0,y:0,z:0}, {x:-1,y:0,z:0}, {x:0,y:-1,z:0}], [{x:0,y:0,z:0}, {x:-1,y:0,z:0}, {x:0,y:1,z:0}],
            [{x:0,y:0,z:0}, {x:0,y:0,z:1}, {x:1,y:0,z:1}], [{x:0,y:0,z:0}, {x:0,y:0,z:1}, {x:-1,y:0,z:1}],
            [{x:0,y:0,z:0}, {x:0,y:0,z:1}, {x:0,y:1,z:1}], [{x:0,y:0,z:0}, {x:0,y:0,z:1}, {x:0,y:-1,z:1}]
        ];
        function getCellsFromBase(bx, by, shapeIdx) { const shape = SHAPES[shapeIdx]; return shape.map(d => ({x: bx + d.x, y: by + d.y, z: d.z})); }

        class GameLogic {
            constructor() { this.reset(); }
            reset() {
                this.board = Array.from({length: 5}, () => Array.from({length: 5}, () => Array(5).fill(0)));
                this.blocks = []; this.history = []; this.turnCount = 0; this.currentPlayer = 1;
                this.blocksLeft = { 1: 4, 2: 4 }; this.phase = 'PLACEMENT'; this.winner = 0;
                this.initFixedBlocks(); this.aiMode = false; this.selectedBlock = null; this.selectedBlockOriginalCells = null;
            }
            clone() { const n = new GameLogic(); n.deserialize(JSON.parse(JSON.stringify(this.serialize()))); return n; }
            serialize() { return { board: this.board, blocks: this.blocks, turnCount: this.turnCount, currentPlayer: this.currentPlayer, blocksLeft: this.blocksLeft, phase: this.phase, winner: this.winner }; }
            deserialize(data) { Object.assign(this, data); }
            initFixedBlocks() {
                this.blocks = []; this.board = Array.from({length: 5}, () => Array.from({length: 5}, () => Array(5).fill(0)));
                this.addBlock(1, [{x:1, y:3, z:0}, {x:2, y:3, z:0}, {x:1, y:2, z:0}], 0, true);
                this.addBlock(2, [{x:2, y:1, z:0}, {x:3, y:1, z:0}, {x:3, y:2, z:0}], 0, true);
            }
            addBlock(player, cells, shapeIdx, isFixed=false) {
                const blockId = Date.now() + Math.random(); this.blocks.push({ id: blockId, player, cells, shapeIdx, isFixed });
                cells.forEach(c => this.board[c.z][c.y][c.x] = player);
            }
            removeBlock(blockId) {
                const idx = this.blocks.findIndex(b => b.id === blockId);
                if (idx > -1) { const block = this.blocks[idx]; block.cells.forEach(c => this.board[c.z][c.y][c.x] = 0); this.blocks.splice(idx, 1); return block; } return null;
            }
            canPick(block) {
                if (block.isFixed) return false;
                for (let c of block.cells) {
                    if (c.z >= 4) continue;
                    if (this.board[c.z+1][c.y][c.x] !== 0) { const isSelf = block.cells.some(sc => sc.x===c.x && sc.y===c.y && sc.z===c.z+1); if (!isSelf) return false; }
                } return true;
            }
            pickBlock(x, y, z) {
                const block = this.blocks.find(b => b.player === this.currentPlayer && !b.isFixed && b.cells.some(c => c.x===x && c.y===y && c.z===z));
                if (!block) return { ok: false, msg: "ë‚´ ë¸”ë¡ ì•„ë‹˜" };
                if (!this.canPick(block)) return { ok: false, msg: "ë¶ˆê°€: ìœ„ì— ë¸”ë¡ ìˆìŒ" };
                this.saveState(); this.selectedBlockOriginalCells = JSON.parse(JSON.stringify(block.cells)); this.removeBlock(block.id); this.selectedBlock = block; return { ok: true, block: block };
            }
            checkValidity(player, cells, isMovement=false, originalCells=null) {
                if (this.winner !== 0) return { ok: false, msg: "ê²Œì„ ì¢…ë£Œë¨" };
                const origin = originalCells || (isMovement && this.selectedBlockOriginalCells ? this.selectedBlockOriginalCells : null);
                if (isMovement && origin) {
                    const cSet = new Set(cells.map(c=>`${c.x},${c.y},${c.z}`)); const oSet = new Set(origin.map(c=>`${c.x},${c.y},${c.z}`)); 
                    if (cSet.size === oSet.size) { let same = true; for(let k of cSet) if(!oSet.has(k)) { same=false; break; } if(same) return { ok:false, msg:"ì œìë¦¬ ë¶ˆê°€" }; }
                }
                for(let c of cells) { if(c.x<0||c.x>4||c.y<0||c.y>4||c.z<0||c.z>4) return {ok:false, msg:"ë²”ìœ„ ì´ˆê³¼"}; if(this.board[c.z][c.y][c.x]!==0) return {ok:false, msg:"ì´ë¯¸ ìˆìŒ"}; }
                if (!isMovement && this.turnCount < 2) { const restricted = ["0,3","0,4","1,4","3,0","4,0","4,1"]; if(cells.some(c=>c.z===0 && restricted.includes(`${c.x},${c.y}`))) return {ok:false, msg:"ê¸ˆì§€ êµ¬ì—­"}; }
                if ([1,3].indexOf(cells.filter(c=>c.z===0).length) === -1) return {ok:false, msg:"ì ‘ì§€ ìœ„ë°˜"};
                for(let c of cells) { if(c.z>0) { const hasSup = this.board[c.z-1][c.y][c.x]!==0; const isSelf = cells.some(sc=>sc.x===c.x && sc.y===c.y && sc.z===c.z-1); if(!hasSup && !isSelf) return {ok:false, msg:"ì§€ì§€ëŒ€ í•„ìš”"}; } }
                return {ok:true};
            }
            confirmMove(cells, shapeIdx) {
                if (this.phase === 'PLACEMENT') { this.saveState(); this.addBlock(this.currentPlayer, cells, shapeIdx); this.blocksLeft[this.currentPlayer]--; } 
                else { this.addBlock(this.currentPlayer, cells, shapeIdx); this.selectedBlock = null; this.selectedBlockOriginalCells = null; }
                this.winner = this.checkWin();
                if (this.winner === 0) { 
                    this.turnCount++; this.currentPlayer = this.currentPlayer===1 ? 2:1; 
                    if (this.blocksLeft[1] === 0 && this.blocksLeft[2] === 0) this.phase = 'MOVEMENT'; else if (this.blocksLeft[this.currentPlayer] === 0 && this.phase === 'PLACEMENT') this.phase = 'MOVEMENT'; 
                    if(!isOnline && this.aiMode && this.currentPlayer !== myPlayerNum) runAI(); 
                }
                sendMove(); updateWinRateUI();
                return this.winner;
            }
            checkWin() {
                const topMap = Array.from({length: 5}, () => Array(5).fill(0));
                for(let y=0; y<5; y++) { for(let x=0; x<5; x++) { for(let z=4; z>=0; z--) { if(this.board[z][y][x]!==0) { topMap[y][x]=this.board[z][y][x]; break; } } } }
                const dirs = [{dx:1, dy:0}, {dx:0, dy:1}, {dx:1, dy:1}, {dx:1, dy:-1}];
                for(let y=0; y<5; y++) {
                    for(let x=0; x<5; x++) {
                        let c = topMap[y][x]; if(c===0) continue; 
                        for(let d of dirs) { 
                            let cnt=1; 
                            for(let k=1; k<5; k++) { let nx=x+d.dx*k, ny=y+d.dy*k; if(nx>=0&&nx<5&&ny>=0&&ny<5&&topMap[ny][nx]===c) cnt++; else break; } 
                            if(cnt===5) return c; 
                        } 
                    }
                } 
                return 0;
            }
            // ğŸŒŸ ìˆ˜ì •: ë©€í‹° ëª¨ë“œì—ì„œë„ ë¬´ë¥´ê¸°ë¥¼ ìœ„í•´ íˆìŠ¤í† ë¦¬ ì €ì¥
            saveState() { const s = { board: JSON.parse(JSON.stringify(this.board)), blocks: JSON.parse(JSON.stringify(this.blocks)), turnCount: this.turnCount, currentPlayer: this.currentPlayer, blocksLeft: {...this.blocksLeft}, phase: this.phase, winner: this.winner }; this.history.push(s); }
            undo() { if(this.history.length===0) return false; const s = this.history.pop(); Object.assign(this, s); this.selectedBlock=null; this.selectedBlockOriginalCells=null; return true; }
        }

        function getAllValidMoves(logic, player) {
            const moves = [];
            // ğŸŒŸ AIê°€ ë” ë˜‘ë˜‘í•´ì§€ë„ë¡ ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ ê¼¼ê¼¼íˆ íƒìƒ‰ (ì••ì¶• í•´ì œ)
            if (logic.phase === 'PLACEMENT') {
                if (logic.blocksLeft[player] > 0) { 
                    for (let sh = 0; sh < 8; sh++) { 
                        for (let y = 0; y < 5; y++) { 
                            for (let x = 0; x < 5; x++) { 
                                let baseCells = getCellsFromBase(x, y, sh); 
                                for (let dz = 0; dz < 5; dz++) { 
                                    const testCells = baseCells.map(c => ({ x: c.x, y: c.y, z: c.z + dz })); 
                                    if (testCells.some(c => c.z > 4)) break; 
                                    if (logic.checkValidity(player, testCells).ok) { moves.push({ type: 'place', cells: testCells, shapeIdx: sh }); break; } 
                                } 
                            } 
                        } 
                    } 
                }
            } else if (logic.phase === 'MOVEMENT') {
                const myBlocks = logic.blocks.filter(b => b.player === player && !b.isFixed); 
                for (const block of myBlocks) { 
                    if (!logic.canPick(block)) continue; 
                    const tempLogic = logic.clone(); tempLogic.removeBlock(block.id); tempLogic.selectedBlockOriginalCells = block.cells; 
                    for (let sh = 0; sh < 8; sh++) { 
                        for (let y = 0; y < 5; y++) { 
                            for (let x = 0; x < 5; x++) { 
                                let baseCells = getCellsFromBase(x, y, sh); 
                                for (let dz = 0; dz < 5; dz++) { 
                                    const testCells = baseCells.map(c => ({ x: c.x, y: c.y, z: c.z + dz })); 
                                    if (testCells.some(c => c.z > 4)) break; 
                                    if (tempLogic.checkValidity(player, testCells, true, block.cells).ok) { moves.push({ type: 'move', fromId: block.id, cells: testCells, shapeIdx: sh }); break; } 
                                } 
                            } 
                        } 
                    } 
                }
            } 
            return moves;
        }

        const ai = new MCTSAI(); const logic = new GameLogic(); const logEl = document.getElementById('log-console'); const aiLoader = document.getElementById('ai-loader');
        async function autoLoadAI() { try { const res = await fetch('legendary_ai.json'); if (res.ok) { neuralWeights = await res.json(); document.getElementById('ai-status-text').innerText = "âœ… AI ì¥ì°© ì™„ë£Œ!"; document.getElementById('ai-status-text').style.color = "#2ecc71"; } } catch (e) { console.log("Manual load required"); } } autoLoadAI();
        window.loadCustomAI = (input) => { const f = input.files[0]; if(!f) return; const r = new FileReader(); r.onload = (e) => { try { neuralWeights = JSON.parse(e.target.result); document.getElementById('ai-status-text').innerText = "âœ… AI ì¥ì°©!"; document.getElementById('ai-status-text').style.color = "#2ecc71"; alert("AI ë¡œë“œ ì„±ê³µ"); } catch(err) { alert("JSON ì˜¤ë¥˜"); } }; r.readAsText(f); };
        function log(msg) { const div = document.createElement('div'); div.innerText = `> ${msg}`; logEl.insertBefore(div, logEl.firstChild); if(logEl.children.length > 4) logEl.removeChild(logEl.lastChild); }

        const scene = new THREE.Scene(); scene.background = new THREE.Color(0xdfe4ea);
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100); camera.position.set(0, 14, 12); camera.lookAt(0,0,0);
        const renderer = new THREE.WebGLRenderer({antialias:true}); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; document.getElementById('game-canvas').appendChild(renderer.domElement);
        scene.add(new THREE.AmbientLight(0xffffff, 0.6)); const dirLight = new THREE.DirectionalLight(0xffffff, 0.7); dirLight.position.set(5,15,5); dirLight.castShadow=true; scene.add(dirLight);
        const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping=true; controls.maxPolarAngle=Math.PI/2;
        const boardGroup = new THREE.Group(); scene.add(boardGroup); const ghostGroup = new THREE.Group(); scene.add(ghostGroup); const hintGroup = new THREE.Group(); scene.add(hintGroup); const thinkingGroup = new THREE.Group(); scene.add(thinkingGroup);
        function clearThinkingIndicators() { while(thinkingGroup.children.length > 0) thinkingGroup.remove(thinkingGroup.children[0]); }
        function showThinkingIndicator(move) { if (!move || !move.cells) return; drawGhost(move.cells, 0xFFA500, thinkingGroup, 0.4); }
        const hitPlane = new THREE.Mesh(new THREE.PlaneGeometry(6,6), new THREE.MeshBasicMaterial({ visible:false, side:THREE.DoubleSide })); hitPlane.rotation.x=-Math.PI/2; hitPlane.position.y=0.5; scene.add(hitPlane);
        scene.add(new THREE.GridHelper(5,5, 0xbdc3c7, 0xecf0f1)); const basePlate = new THREE.Mesh(new THREE.BoxGeometry(5,0.1,5), new THREE.MeshStandardMaterial({color:0xdeb887})); basePlate.position.y=-0.05; basePlate.receiveShadow=true; scene.add(basePlate);
        let currentShapeIdx=0, hoverX=-1, hoverY=-1, hoveredBlockId=null;

        function updateUI() {
            document.getElementById('p1-cnt').innerText = logic.blocksLeft[1]; document.getElementById('p2-cnt').innerText = logic.blocksLeft[2];
            document.getElementById('name-p1').innerText = p1Name; document.getElementById('name-p2').innerText = p2Name;
            document.getElementById('turn-indicator').innerText = logic.currentPlayer===1?`(${p1Name})`:`(${p2Name})`;
            document.getElementById('turn-indicator').style.color = logic.currentPlayer===1?"#e74c3c":"#2ecc71";
            document.getElementById('game-phase').innerText = logic.phase==='MOVEMENT'?"ì´ë™":"ì°©ìˆ˜";
            document.getElementById('game-phase').style.background = logic.phase==='MOVEMENT'?"#e67e22":"#333";
            const btn = document.getElementById('btn-ai-toggle'); btn.innerText = logic.aiMode ? "ğŸ¤– AI: ON" : "ğŸ¤– AI: OFF"; logic.aiMode ? btn.classList.add('active') : btn.classList.remove('active');
            
            const btnUndo = document.getElementById('btn-undo'); 
            if (isOnline) { btnUndo.innerText = "â†©ï¸ ìš”ì²­"; btnUndo.onclick = window.requestUndo; } else { btnUndo.innerText = "â†©ï¸ ë¬´ë¥´ê¸°"; btnUndo.onclick = window.undo; }

            const btnResign = document.getElementById('btn-resign');
            if(isOnline && !isSpectator) btnResign.style.display = 'inline-block';
            else btnResign.style.display = 'none';

            document.getElementById('btn-reset').style.display = isOnline ? 'none' : 'inline-block';
        }
        
        // ğŸŒŸ ìŠ¹ë¥  ë°” ìˆ˜ì •: ì‚¬ë¼ì§€ì§€ ì•Šê³  í•­ìƒ í‘œì‹œ
        function updateWinRateUI() {
            if (logic.winner !== 0) { 
                document.getElementById('win-rate-text').innerText = logic.winner === 1 ? "í‘ ìŠ¹ë¦¬!" : "ë°± ìŠ¹ë¦¬!"; 
                document.getElementById('win-rate-fill').style.height = logic.winner === 1 ? "100%" : "0%"; 
                return; 
            }
            setTimeout(() => { 
                // í˜„ì¬ í„´ì¸ ì‚¬ëŒì˜ ìŠ¹ë¥ ì„ êµ¬í•¨
                const winRate = ai.getWinRate(logic, logic.currentPlayer, 500); 
                // í‘(Player 1) ê¸°ì¤€ ìŠ¹ë¥ ë¡œ ë³€í™˜
                let blackWinRate = logic.currentPlayer === 1 ? winRate : (100 - winRate); 
                document.getElementById('win-rate-text').innerText = `í‘ ìŠ¹ë¥ : ${Math.round(blackWinRate)}%`; 
                document.getElementById('win-rate-fill').style.height = `${Math.round(blackWinRate)}%`; 
            }, 10);
        }

        function renderBoard() {
            for(let i=boardGroup.children.length-1; i>=0; i--) boardGroup.remove(boardGroup.children[i]);
            const geo = new RoundedBoxGeometry(0.98,0.98,0.98, 4, 0.1);
            logic.blocks.forEach(b => {
                const isHov = b.id===hoveredBlockId; const col = b.player===1 ? (isHov?0x555555:0x333333) : (isHov?0xffffff:0xeeeeee); const mat = new THREE.MeshStandardMaterial({color:col, roughness:0.3}); const grp = new THREE.Group(); grp.userData={id:b.id, isBlock:true};
                b.cells.forEach(c=>{ const m = new THREE.Mesh(geo, mat); m.position.set(c.x-2, c.z+0.5, c.y-2); m.castShadow=true; m.receiveShadow=true; m.userData={id:b.id, parentGroup:grp}; grp.add(m); });
                for(let i=0; i<b.cells.length; i++) for(let j=i+1; j<b.cells.length; j++) { const c1=b.cells[i], c2=b.cells[j]; if(Math.abs(c1.x-c2.x)+Math.abs(c1.y-c2.y)+Math.abs(c1.z-c2.z)===1) { let bg; if(Math.abs(c1.x-c2.x)===1) bg=new THREE.BoxGeometry(1,0.8,0.8); else if(Math.abs(c1.y-c2.y)===1) bg=new THREE.BoxGeometry(0.8,0.8,1); else bg=new THREE.BoxGeometry(0.8,1,0.8); const br=new THREE.Mesh(bg, mat); br.position.set((c1.x+c2.x)/2-2, (c1.z+c2.z)/2+0.5, (c1.y+c2.y)/2-2); grp.add(br); } } boardGroup.add(grp);
            });
        }
        function updateGhost() {
            while(ghostGroup.children.length>0) ghostGroup.remove(ghostGroup.children[0]);
            if(logic.winner!==0 || isSpectator || (isOnline && logic.currentPlayer!==myPlayerNum) || (logic.phase==='MOVEMENT' && !logic.selectedBlock) || hoverX===-1) return;
            const sh = SHAPES[currentShapeIdx%8]; const cells = sh.map(c=>({x:hoverX+c.x, y:hoverY+c.y, z:c.z})); const chk = logic.checkValidity(logic.currentPlayer, cells, logic.phase==='MOVEMENT'); drawGhost(cells, chk.ok?0x2ecc71:0xe74c3c, ghostGroup, 0.6);
        }
        function drawGhost(cells, col, grp, op) { const mat = new THREE.MeshBasicMaterial({color:col, transparent:true, opacity:op}); const geo = new RoundedBoxGeometry(0.96,0.96,0.96, 4, 0.1); cells.forEach(c=>{ const m = new THREE.Mesh(geo, mat); m.position.set(c.x-2, c.z+0.52, c.y-2); grp.add(m); }); }

        window.showSideSelection = () => { myNickname = document.getElementById('nickname-input').value || "Player"; p1Name = myNickname; p2Name = "AI Robot"; document.getElementById('lobby-main').style.display='none'; document.getElementById('lobby-side').style.display='block'; };
        window.startSingleGame = (playerNum) => {
            isOnline = false; myPlayerNum = playerNum; if(myPlayerNum === 2) { p1Name = "AI Robot"; p2Name = myNickname; }
            enterGameMode("single");
            const badge = document.getElementById('my-player-badge'); badge.innerText = "ğŸ‘¤ ì‹±ê¸€ ëª¨ë“œ"; badge.style.background = "#333";
            logic.aiMode = true; updateUI(); updateWinRateUI();
            if(myPlayerNum === 2) { setTimeout(runAI, 500); }
        };

        window.createRoom = () => {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; let code = ''; for(let i=0; i<6; i++) code += chars.charAt(Math.floor(Math.random() * chars.length));
            myRoomId = code; myPlayerNum = 1; myNickname = document.getElementById('nickname-input').value || "Host"; p1Name = myNickname; p2Name = "ëŒ€ê¸°ì¤‘...";
            set(ref(db, 'rooms/' + code), { status: 'waiting', board: logic.serialize(), undoReq: null, hintReq: null, players: { 1: myNickname, 2: "" }, gameReq: null });
            document.getElementById('lobby-main').style.display = 'none'; document.getElementById('lobby-wait').style.display = 'block'; document.getElementById('display-room-code').innerText = code;
            onValue(ref(db, 'rooms/' + code + '/players/2'), (snap) => { if (snap.val()) { p2Name = snap.val(); update(ref(db, 'rooms/' + code), { status: 'playing' }); startGameMulti(1); } });
        };
        window.joinRoom = () => {
            const code = document.getElementById('room-code-input').value.toUpperCase(); if(code.length !== 6) { alert("ì½”ë“œ 6ìë¦¬!"); return; } myNickname = document.getElementById('nickname-input').value || "Guest";
            get(child(ref(db), 'rooms/' + code)).then((snap) => {
                if (snap.exists()) {
                    const roomData = snap.val();
                    if (roomData.status === 'playing') {
                        if (confirm("ë°©ì´ ê½‰ ì°¼ìŠµë‹ˆë‹¤. ê´€ì „í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) { myRoomId = code; myPlayerNum = 3; isSpectator = true; p1Name = roomData.players[1]; p2Name = roomData.players[2]; startGameMulti(3); }
                    } else { myRoomId = code; myPlayerNum = 2; p1Name = roomData.players[1]; p2Name = myNickname; update(ref(db, 'rooms/' + code + '/players'), { 2: myNickname }); startGameMulti(2); }
                } else alert("ë°© ì—†ìŒ");
            });
        };

        function enterGameMode(hash) {
            location.hash = hash;
            document.getElementById('lobby-overlay').style.display = 'none'; document.getElementById('ui-layer').style.display = 'flex'; document.getElementById('game-canvas').style.display = 'block'; document.getElementById('win-rate-bar-container').style.display = 'block'; document.getElementById('win-rate-text').style.display = 'block';
        }

        function startGameMulti(pNum) {
            enterGameMode("multi");
            isOnline = true; document.getElementById('btn-ai-toggle').style.display = 'none'; document.getElementById('btn-reset').style.display = 'none';
            const badge = document.getElementById('my-player-badge');
            if (isSpectator) { badge.innerText = "ğŸ‘€ ê´€ì „ ëª¨ë“œ"; badge.style.background = "#7f8c8d"; } else { badge.innerText = pNum===1 ? "ğŸŒ Host (í‘)" : "ğŸŒ Guest (ë°±)"; badge.style.background = pNum===1 ? "#e74c3c" : "#2ecc71"; }
            
            // ğŸŒŸ ìˆ˜ì •: ìƒëŒ€ë°© ìˆ˜ë¥¼ ë°›ì•„ì˜¬ ë•Œë„ ìƒíƒœ ì €ì¥ (ë¬´ë¥´ê¸°ìš©)
            onValue(ref(db, 'rooms/' + myRoomId + '/board'), (snap) => { 
                if (snap.val()) { 
                    if(logic.turnCount > 0) logic.saveState();
                    logic.deserialize(snap.val()); renderBoard(); updateUI(); updateWinRateUI(); checkMultiGameEnd(); 
                } 
            });
            onValue(ref(db, 'rooms/' + myRoomId + '/players'), (snap) => { const players = snap.val(); if(players) { p1Name=players[1]; p2Name=players[2]; updateUI(); } });
            
            // ğŸŒŸ ìˆ˜ì •: ëª¨ë‹¬ íŒì—…ìœ¼ë¡œ ìš”ì²­ ì²˜ë¦¬
            onValue(ref(db, 'rooms/' + myRoomId + '/undoReq'), (snap) => { 
                const req = snap.val(); if(!req) { document.getElementById('req-modal').style.display='none'; return; }
                if(req.status==='rejected' && req.requester===myPlayerNum) { alert("ë¬´ë¥´ê¸° ê±°ì ˆë¨"); set(ref(db, 'rooms/' + myRoomId + '/undoReq'), null); }
                if(req.status==='pending' && req.requester!==myPlayerNum && !isSpectator) { 
                    showReqModal("ìƒëŒ€ë°©ì´ ë¬´ë¥´ê¸°ë¥¼ ìš”ì²­í–ˆìŠµë‹ˆë‹¤.", () => {
                        logic.undo(); logic.undo(); 
                        set(ref(db, 'rooms/' + myRoomId + '/board'), logic.serialize()); 
                        set(ref(db, 'rooms/' + myRoomId + '/undoReq'), null);
                    }, () => {
                        update(ref(db, 'rooms/' + myRoomId + '/undoReq'), {status:'rejected'});
                    });
                }
            });
            onValue(ref(db, 'rooms/' + myRoomId + '/hintReq'), (snap) => { 
                const req = snap.val(); if(!req) { document.getElementById('req-modal').style.display='none'; return; }
                if(req.status==='granted' && req.requester===myPlayerNum) { alert("íŒíŠ¸ í—ˆìš©ë¨!"); set(ref(db, 'rooms/' + myRoomId + '/hintReq'), null); window.actuallyShowHint(); }
                if(req.status==='rejected' && req.requester===myPlayerNum) { alert("íŒíŠ¸ ê±°ì ˆë¨"); set(ref(db, 'rooms/' + myRoomId + '/hintReq'), null); }
                if(req.status==='pending' && req.requester!==myPlayerNum && !isSpectator) { 
                    showReqModal(`ìƒëŒ€ë°©(${req.requester===1?p1Name:p2Name})ì´ AI íŒíŠ¸ë¥¼ ìš”ì²­í–ˆìŠµë‹ˆë‹¤.`, () => {
                        update(ref(db, 'rooms/' + myRoomId + '/hintReq'), {status:'granted'});
                    }, () => {
                        update(ref(db, 'rooms/' + myRoomId + '/hintReq'), {status:'rejected'});
                    });
                }
            });
            onValue(ref(db, 'rooms/' + myRoomId + '/gameReq'), (snap) => {
                const req = snap.val(); if(!req) return;
                if(req.type === 'restart') {
                    alert("ì¬ëŒ€ê²°ì´ ì‹œì‘ë©ë‹ˆë‹¤! (í‘ë°± êµì²´)");
                    const newBoard = new GameLogic(); 
                    set(ref(db, 'rooms/' + myRoomId + '/board'), newBoard.serialize());
                    set(ref(db, 'rooms/' + myRoomId + '/gameReq'), null);
                    document.getElementById('end-modal').style.display = 'none';
                }
            });
        }

        // ğŸŒŸ ìš”ì²­ ëª¨ë‹¬ í‘œì‹œ í•¨ìˆ˜
        function showReqModal(msg, onYes, onNo) {
            document.getElementById('req-msg').innerText = msg;
            document.getElementById('btn-req-yes').onclick = () => { onYes(); document.getElementById('req-modal').style.display='none'; };
            document.getElementById('btn-req-no').onclick = () => { onNo(); document.getElementById('req-modal').style.display='none'; };
            document.getElementById('req-modal').style.display='flex';
        }

        window.resign = () => {
            if(!isOnline || isSpectator || logic.winner !== 0) return;
            if(confirm("ì •ë§ ê¸°ê¶Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ìƒëŒ€ë°©ì˜ ìŠ¹ë¦¬ë¡œ ê¸°ë¡ë©ë‹ˆë‹¤)")) {
                logic.winner = (myPlayerNum === 1) ? 2 : 1; 
                set(ref(db, 'rooms/' + myRoomId + '/board'), logic.serialize());
            }
        };

        function checkMultiGameEnd() {
            if(logic.winner !== 0) {
                const winnerName = logic.winner === 1 ? p1Name : p2Name;
                document.getElementById('end-title').innerText = `${winnerName} ìŠ¹ë¦¬!`;
                document.getElementById('end-msg').innerText = "ë‹¤ìŒ ê²Œì„ì„ ì–´ë–»ê²Œ ì§„í–‰í• ê¹Œìš”?";
                
                const btnGroup = document.getElementById('end-btns');
                btnGroup.innerHTML = "";
                const isLoser = (logic.winner === 1 && myPlayerNum === 2) || (logic.winner === 2 && myPlayerNum === 1);
                
                if (isLoser && !isSpectator) {
                    const btnRematch = document.createElement('button');
                    btnRematch.className = 'lobby-btn btn-create';
                    btnRematch.innerText = "ğŸ”„ ê¸°ì¡´ ìƒëŒ€ì™€ ì¬ëŒ€ê²° (í‘ë°± êµì²´)";
                    btnRematch.onclick = () => { set(ref(db, 'rooms/' + myRoomId + '/gameReq'), { type: 'restart' }); };
                    btnGroup.appendChild(btnRematch);
                } else {
                    const waitMsg = document.createElement('div');
                    waitMsg.innerText = "íŒ¨ë°°ìì˜ ì„ íƒì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...";
                    btnGroup.appendChild(waitMsg);
                }
                document.getElementById('end-modal').style.display = 'flex';
            } else {
                document.getElementById('end-modal').style.display = 'none';
            }
        }

        window.requestUndo = () => { if (!isOnline || isSpectator) return; if (confirm("ë¬´ë¥´ê¸° ìš”ì²­?")) set(ref(db, 'rooms/' + myRoomId + '/undoReq'), { requester: myPlayerNum, status: 'pending' }); }
        function sendMove() { if (isOnline && !isSpectator) set(ref(db, 'rooms/' + myRoomId + '/board'), logic.serialize()); }
        window.askAI = async () => { if (logic.winner !== 0) return; if (isOnline) { if (isSpectator) return; if (confirm("ë©€í‹° ëª¨ë“œ: ìƒëŒ€ë°© ë™ì˜ í•„ìš”. ìš”ì²­?")) set(ref(db, 'rooms/' + myRoomId + '/hintReq'), { requester: myPlayerNum, status: 'pending' }); } else window.actuallyShowHint(); };
        window.actuallyShowHint = async () => { const l=document.getElementById('ai-loader'); l.innerText="ğŸ’¡ íŒíŠ¸..."; l.style.display='block'; await new Promise(r=>setTimeout(r,10)); clearThinkingIndicators(); while(hintGroup.children.length>0) hintGroup.remove(hintGroup.children[0]); const m=await ai.getBestMove(logic, logic.currentPlayer, 1500, (tm)=> { clearThinkingIndicators(); showThinkingIndicator(tm); }); clearThinkingIndicators(); l.style.display='none'; if(m){ if(m.type==='move') { const s=logic.blocks.find(b=>b.id===m.fromId); if(s) drawGhost(s.cells,0xff4444,hintGroup,0.6); } drawGhost(m.cells,0xf1c40f,hintGroup,0.8); } else log("AI: ê¸°ê¶Œ"); };
        async function runAI() { const l=document.getElementById('ai-loader'); l.innerText="ğŸ¤– ìƒê°ì¤‘..."; l.style.display='block'; await new Promise(r=>setTimeout(r,10)); clearThinkingIndicators(); const m=await ai.getBestMove(logic, logic.currentPlayer, 1500, (tm)=>{ clearThinkingIndicators(); showThinkingIndicator(tm); }); clearThinkingIndicators(); l.style.display='none'; if(m) { if(m.type==='place') logic.confirmMove(m.cells, m.shapeIdx); else { const b=logic.blocks.find(x=>x.id===m.fromId); if(b) { logic.selectedBlockOriginalCells=JSON.parse(JSON.stringify(b.cells)); logic.removeBlock(b.id); logic.selectedBlock=b; logic.confirmMove(m.cells, m.shapeIdx); } } log("AI ì™„ë£Œ"); renderBoard(); updateUI(); updateGhost(); setTimeout(()=>{ if(logic.winner!==0) alert(`ê²Œì„ ì¢…ë£Œ! ìŠ¹ì: ${logic.winner}`); },200); } else log("AI ê¸°ê¶Œ"); }
        window.toggleAIMode = () => { logic.aiMode=!logic.aiMode; updateUI(); if(!isOnline && logic.aiMode && logic.currentPlayer !== myPlayerNum) runAI(); };
        window.undo = () => { if(!isOnline && logic.undo()) { log("ë¬´ë¥´ê¸°"); hoveredBlockId=null; while(hintGroup.children.length>0) hintGroup.remove(hintGroup.children[0]); renderBoard(); updateUI(); updateWinRateUI(); } };
        window.resetGame = () => { if(!isOnline && confirm("ì´ˆê¸°í™”?")) { logic.reset(); hoveredBlockId=null; while(hintGroup.children.length>0) hintGroup.remove(hintGroup.children[0]); renderBoard(); updateUI(); updateWinRateUI(); log("ì´ˆê¸°í™”ë¨"); } };
        document.onkeydown = (e) => { if(e.code==='KeyR') { currentShapeIdx++; updateGhost(); } if(e.code==='KeyZ') { if(isOnline) window.requestUndo(); else window.undo(); } };
        document.getElementById('btn-rotate').addEventListener('click', e=>{ e.stopPropagation(); currentShapeIdx++; updateGhost(); });
        window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        
        const ray = new THREE.Raycaster(); const mouse = new THREE.Vector2(); let downTime=0;
        window.addEventListener('mousemove', e=>{ mouse.x=(e.clientX/window.innerWidth)*2-1; mouse.y=-(e.clientY/window.innerHeight)*2+1; ray.setFromCamera(mouse, camera); if(isSpectator || (isOnline && logic.currentPlayer!==myPlayerNum)) return; if(logic.phase==='MOVEMENT' && !logic.selectedBlock) { const ints = ray.intersectObjects(boardGroup.children, true); if(ints.length>0) { const bid = ints[0].object.userData.id; if(bid && bid!==hoveredBlockId) { hoveredBlockId=bid; renderBoard(); } hoverX=-1; updateGhost(); return; } else if(hoveredBlockId!==null) { hoveredBlockId=null; renderBoard(); } } const ints = ray.intersectObject(hitPlane); if(ints.length>0) { const p=ints[0].point; const gx=Math.floor(p.x+2.5), gy=Math.floor(p.z+2.5); if(gx>=0&&gx<5&&gy>=0&&gy<5) { if(hoverX!==gx||hoverY!==gy) { hoverX=gx; hoverY=gy; updateGhost(); } } else { hoverX=-1; updateGhost(); } } else { hoverX=-1; updateGhost(); } });
        window.addEventListener('mousedown', ()=>downTime=Date.now()); window.addEventListener('mouseup', ()=>{ if(Date.now()-downTime<250) click(); });
        function click() { if(logic.winner!==0 || isSpectator || (isOnline && logic.currentPlayer!==myPlayerNum)) return; while(hintGroup.children.length>0) hintGroup.remove(hintGroup.children[0]); if(logic.phase==='MOVEMENT' && !logic.selectedBlock) { if(hoveredBlockId) { const b=logic.blocks.find(x=>x.id===hoveredBlockId); if(b) { const r=logic.pickBlock(b.cells[0].x, b.cells[0].y, b.cells[0].z); if(r.ok) { currentShapeIdx=r.block.shapeIdx; hoveredBlockId=null; renderBoard(); } else log(r.msg); } } return; } if(hoverX!==-1) { const sh=SHAPES[currentShapeIdx%8]; const cells=sh.map(c=>({x:hoverX+c.x, y:hoverY+c.y, z:c.z})); const chk=logic.checkValidity(logic.currentPlayer, cells, logic.phase==='MOVEMENT'); if(chk.ok) { logic.confirmMove(cells, currentShapeIdx%8); log("ì°©ìˆ˜"); renderBoard(); updateUI(); updateGhost(); setTimeout(()=>{ if(logic.winner!==0) alert(`ê²Œì„ ì¢…ë£Œ! ìŠ¹ì: ${logic.winner}`); },200); } else log(chk.msg); } }
        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
        renderBoard(); updateUI(); animate();
    </script>
</body>
</html>