<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ëŒ€í•™ì „ìŸ: ë¸”ë¡ ì˜¤ëª© (Neural AI v5)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; background: #dfe4ea; font-family: 'Pretendard', sans-serif; user-select: none; -webkit-touch-callout: none; }
        #game-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; height: 100dvh; z-index: 1; touch-action: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; height: 100dvh; z-index: 10; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        .top-bar { pointer-events: auto; display: flex; flex-direction: column; gap: 8px; background: rgba(255,255,255,0.95); padding: 12px 15px; margin: 10px; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
        .row-upper { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        .row-lower { display: flex; justify-content: space-between; align-items: center; width: 100%; margin-top: 5px; }
        .title-row { display: flex; align-items: center; gap: 8px; font-size: 1.1rem; }
        .score-box { font-weight: bold; font-size: 1rem; }
        .p1 { color: #e74c3c; } .p2 { color: #2ecc71; } 
        
        .btn { background: #fff; border: 1px solid #ccc; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 0.9rem; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.05); transition: all 0.2s; }
        .btn:active { transform: translateY(1px); background: #f0f0f0; }
        .btn-hint { background: #f1c40f; border-color: #f39c12; color: #fff; }
        .btn-ai-toggle { background: #ecf0f1; color: #7f8c8d; }
        .btn-ai-toggle.active { background: #2ecc71; color: white; border-color: #27ae60; }
        
        .phase-badge { font-size: 0.75rem; color: white; padding: 4px 8px; border-radius: 4px; background: #333; vertical-align: middle; }
        
        /* íŒŒì¼ ì—…ë¡œë“œ ìŠ¤íƒ€ì¼ */
        .ai-upload-box { margin-top: 10px; font-size: 0.8rem; color: #666; display: flex; align-items: center; gap: 10px; }
        #brain-status { font-weight: bold; color: #e74c3c; }
        
        .fab-rotate-container { position: absolute; right: 20px; bottom: 30px; display: flex; flex-direction: column; align-items: center; pointer-events: auto; }
        .fab-rotate { width: 70px; height: 70px; background: #fff; color: #333; border-radius: 50%; border: 2px solid #ddd; display: flex; justify-content: center; align-items: center; font-size: 2.2rem; cursor: pointer; box-shadow: 0 6px 15px rgba(0,0,0,0.2); transition: transform 0.1s; }
        .fab-rotate:active { transform: scale(0.95); background: #f9f9f9; }
        .key-hint { font-size: 0.7rem; color: #666; margin-top: 5px; font-weight: bold; text-shadow: 1px 1px 0 #fff; }

        .fab-rules { pointer-events: auto; position: absolute; left: 20px; bottom: 30px; width: 45px; height: 45px; background: #3498db; color: white; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 1.2rem; cursor: pointer; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
        .log-panel { pointer-events: none; position: absolute; left: 20px; bottom: 85px; background: rgba(0,0,0,0.6); color: #fff; width: 250px; height: 120px; border-radius: 8px; padding: 10px; overflow: hidden; font-family: monospace; font-size: 0.8rem; display: flex; flex-direction: column-reverse; text-shadow: 1px 1px 2px black; }
        
        #lobby-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.95); z-index: 200; display: flex; flex-direction: column; justify-content: center; align-items: center; pointer-events: auto; }
        .lobby-box { text-align: center; background: white; padding: 40px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.15); width: 85%; max-width: 400px; }
        .lobby-title { font-size: 2rem; font-weight: bold; margin-bottom: 30px; color: #2c3e50; }
        .lobby-btn { width: 100%; padding: 15px; margin: 10px 0; font-size: 1.1rem; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; color: white; transition: transform 0.1s; }
        .btn-single { background: #9b59b6; } .btn-create { background: #3498db; } .btn-join { background: #2ecc71; }
        
        #ai-loader { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 15px 30px; border-radius: 30px; font-weight: bold; font-size: 1.2rem; z-index: 50; pointer-events: none; backdrop-filter: blur(5px); }
        #my-player-badge { font-size: 0.9rem; font-weight: bold; padding: 6px 12px; border-radius: 20px; display: inline-block; }
        
        .modal-overlay { pointer-events: auto; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: none; justify-content: center; align-items: center; z-index: 300; }
        .modal-content { background: white; width: 85%; max-width: 500px; max-height: 85%; border-radius: 12px; padding: 25px; overflow-y: auto; position: relative; }
        .close-btn { position: absolute; top: 15px; right: 20px; font-size: 1.5rem; cursor: pointer; color: #888; }
        h3 { margin-top: 0; border-bottom: 2px solid #eee; padding-bottom: 10px; }
    </style>
    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } } </script>
</head>
<body>
    <div id="lobby-overlay">
        <div class="lobby-box">
            <div class="lobby-title">ğŸ§  ì „ì„¤ì˜ AI ì˜¤ëª© <br><span style="font-size:1rem; color:#e74c3c;">(Neural Network Ver.)</span></div>
            
            <div id="lobby-main">
                <button class="lobby-btn btn-single" onclick="showSideSelection()">ğŸ‘¤ AIì™€ í•œíŒ ìŠ¹ë¶€</button>
                
                <div class="ai-upload-box">
                    <label for="brain-upload" class="btn" style="background:#eee; font-size:0.8rem;">ğŸ“‚ AI ë‡Œ(JSON) ì—…ë¡œë“œ</label>
                    <input type="file" id="brain-upload" accept=".json" style="display:none;" onchange="loadBrain(this)">
                    <span id="brain-status">âŒ ë‡Œ ì—†ìŒ (ì—…ë¡œë“œ í•„ìš”)</span>
                </div>
            </div>

            <div id="lobby-side" style="display:none;">
                <h3 style="margin-bottom:20px; color:#2c3e50;">ì§„ì˜ì„ ì„ íƒí•˜ì„¸ìš”</h3>
                <button class="lobby-btn" style="background:#333; color:white;" onclick="startSingleGame(1)">âš« í‘ëŒ (ì„ ê³µ)</button>
                <button class="lobby-btn" style="background:#eee; color:#333; border:1px solid #ccc;" onclick="startSingleGame(2)">âšª ë°±ëŒ (í›„ê³µ)</button>
                <button class="btn" onclick="location.reload()" style="margin-top:20px; width:100%;">ì·¨ì†Œ</button>
            </div>
        </div>
    </div>

    <div id="game-canvas"></div>
    <div id="ai-loader">ğŸ§  AI ê³„ì‚° ì¤‘...</div>

    <div id="ui-layer" style="display:none;">
        <div class="top-bar">
            <div class="row-upper">
                <div class="game-info">
                    <div class="title-row"> <span style="font-weight:bold;">BLOCK OMOK</span> <span id="game-phase" class="phase-badge">ì°©ìˆ˜</span> </div>
                    <div class="score-box"> <span class="p1">í‘: <span id="p1-cnt">4</span></span> <span style="margin:0 5px; color:#ccc">|</span> <span class="p2">ë°±: <span id="p2-cnt">4</span></span> <span id="turn-indicator" style="font-size:0.9rem; margin-left:5px; color:#e74c3c;">(í‘ ì°¨ë¡€)</span> </div>
                </div>
                <div class="btn-group"> 
                    <button class="btn" id="btn-undo" onclick="window.undo()">â†©ï¸ ë¬´ë¥´ê¸°</button> 
                    <button class="btn" onclick="window.resetGame()">ğŸ”„ ì´ˆê¸°í™”</button> 
                </div>
            </div>
            <div class="row-lower">
                <div id="my-player-badge">ì‹±ê¸€ ëª¨ë“œ</div>
                <button id="btn-ai-toggle" class="btn btn-ai-toggle" onclick="window.toggleAIMode()">ğŸ¤– AI ëŒ€ì „: ON</button>
                <button class="btn btn-hint" onclick="window.askAI()">ğŸ’¡ íŒíŠ¸</button>
            </div>
        </div>
        <div class="log-panel" id="log-console">
            <div>ğŸ‘† JSON íŒŒì¼ì„ ì—…ë¡œë“œí•˜ì„¸ìš”!</div>
            <div>ğŸš€ ê²Œì„ ì‹œì‘!</div>
        </div>
        
        <div class="fab-rotate-container">
            <div class="fab-rotate" id="btn-rotate">â†»</div>
            <div class="key-hint">(PC: Rí‚¤)</div>
        </div>
        
        <div class="fab-rules" onclick="document.getElementById('rule-modal').style.display='flex'">?</div>
    </div>

    <div id="rule-modal" class="modal-overlay" onclick="if(event.target===this) this.style.display='none'">
        <div class="modal-content">
            <span class="close-btn" onclick="document.getElementById('rule-modal').style.display='none'">&times;</span>
            <h3>ğŸ“œ ê²Œì„ ê·œì¹™</h3>
            <div class="rule-desc">
                1. <b>ìœ„ì—ì„œ ë´¤ì„ ë•Œ 5ëª©</b>ì´ë©´ ìŠ¹ë¦¬í•©ë‹ˆë‹¤.<br>
                2. ë¸”ë¡ì€ 1ì¸µ ë°”ë‹¥ì— ë‹¿ê±°ë‚˜, ë‹¤ë¥¸ ë¸”ë¡ ìœ„ì— ì˜¬ë ¤ì•¼ í•©ë‹ˆë‹¤.<br>
                3. ë¸”ë¡ 4ê°œë¥¼ ë‹¤ ì“°ë©´, ê¸°ì¡´ ë¸”ë¡ì„ <b>ì´ë™</b>í•´ì•¼ í•©ë‹ˆë‹¤.
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

        let myPlayerNum = 0; 
        let neuralWeights = null; // AI ë‡Œ ë°ì´í„°

        // =========================================================
        // ğŸ§  Neural Network AI Implementation (Matrix Math)
        // =========================================================
        class NeuralAI {
            constructor(weights) { 
                this.weights = weights; 
                this.ready = !!weights;
            }
            
            // 1. ê´€ì°° ë°ì´í„° ìƒì„± (íŒŒì´ì¬ê³¼ ìˆœì„œ 100% ì¼ì¹˜)
            getObservation(logic, player) {
                const obs = [];
                const p = player;
                const opp = p === 1 ? 2 : 1;
                
                // ìˆœì„œ: Z(0->4), Y(0->4), X(0->4) (íŒŒì´ì¬ flatten ê¸°ë³¸ ìˆœì„œ)
                // ë‚´ ëŒ ì§€ë„ (125ê°œ)
                for(let z=0; z<5; z++) {
                    for(let y=0; y<5; y++) {
                        for(let x=0; x<5; x++) {
                            obs.push(logic.board[z][y][x] === p ? 1 : 0);
                        }
                    }
                }
                // ìƒëŒ€ ëŒ ì§€ë„ (125ê°œ)
                for(let z=0; z<5; z++) {
                    for(let y=0; y<5; y++) {
                        for(let x=0; x<5; x++) {
                            obs.push(logic.board[z][y][x] === opp ? 1 : 0);
                        }
                    }
                }
                return obs; // ì´ 250ê°œ
            }

            // 2. í–‰ë ¬ ì—°ì‚° (Forward Propagation)
            matMul(input, weights, bias) {
                const output = new Array(bias.length).fill(0);
                for (let j = 0; j < bias.length; j++) {
                    let sum = bias[j];
                    for (let i = 0; i < input.length; i++) {
                        sum += input[i] * weights[i][j]; // weights[input_idx][output_idx]
                    }
                    output[j] = sum;
                }
                return output;
            }

            // 3. ì˜ˆì¸¡ (ê°€ì¥ ë†’ì€ ì ìˆ˜ì˜ ìœ íš¨í•œ í–‰ë™ ì„ íƒ)
            getBestMove(logic, player) {
                if (!this.ready) return null;

                // ìœ íš¨í•œ ìˆ˜ í™•ì¸ (ë§ˆìŠ¤í‚¹ìš©)
                const validMoves = getAllValidMoves(logic, player); // ê¸°ì¡´ í•¨ìˆ˜ ì¬ì‚¬ìš©
                if (validMoves.length === 0) return null;

                // ìœ íš¨ í–‰ë™ ì¸ë±ìŠ¤ ë§µí•‘
                const validIndices = new Set();
                const moveMap = {}; // index -> moveObj
                
                for(let m of validMoves) {
                    let idx = -1;
                    if(m.type === 'place') {
                        // Place Action: Index = Shape * 25 + Y * 5 + X
                        // ì£¼ì˜: íŒŒì´ì¬ ê³µì‹: i = shape*25 + px*5 + py ??? 
                        // ì•„ë‹ˆìš”, ì•„ê¹Œ í™•ì¸í•œ ê³µì‹: i = py*40 + px*8 + shape -> (Y, X, S) ìˆœì„œ?
                        // ë‹¤ì‹œ íŒŒì´ì¬ ê³µì‹ í™•ì¸:
                        // sh = i % 8
                        // px = (i // 8) % 5
                        // py = (i // 8) // 5
                        // ì¦‰, i = py * 40 + px * 8 + sh
                        const px = m.cells[0].x - SHAPES[m.shapeIdx][0].x; // ê¸°ì¤€ì  ì—­ì‚° í•„ìš”... ë³µì¡í•¨.
                        // ê°„ë‹¨í•˜ê²Œ: ëª¨ë“  200ê°œ ì•¡ì…˜ì— ëŒ€í•´ ìœ íš¨ì„± ê²€ì‚¬ë¥¼ ë‹¤ì‹œ í•˜ëŠ”ê²Œ ì•ˆì „í•¨.
                    }
                }

                // ë” í™•ì‹¤í•œ ë°©ë²•: 0~199 ëª¨ë“  ì•¡ì…˜ì— ëŒ€í•´ ìœ íš¨ì„± ê²€ì‚¬ ìˆ˜í–‰ (ë§ˆìŠ¤í‚¹)
                const validActionIndices = [];
                const actionToMoveObj = {};

                if (logic.blocksLeft[player] > 0) {
                    // ë°°ì¹˜ ë‹¨ê³„
                    for(let i=0; i<200; i++) {
                        const sh = i % 8;
                        const px = Math.floor(i / 8) % 5;
                        const py = Math.floor(i / 8) / 5; // ì •ìˆ˜ ë‚˜ëˆ—ì…ˆ
                        
                        const cells = getCellsFromBase(px, py, sh);
                        if (logic.checkValidity(player, cells).ok) {
                            validActionIndices.push(i);
                            actionToMoveObj[i] = { type: 'place', cells, shapeIdx: sh };
                        }
                    }
                } else {
                    // ì´ë™ ë‹¨ê³„ (AIê°€ ì§€ì›í•´ì•¼ í•¨. í˜„ì¬ AIëŠ” ì´ë™ê¹Œì§€ í•™ìŠµí–ˆìŒ)
                    // í•˜ì§€ë§Œ ì´ë™ì€ 'ì–´ë–¤ ëŒ'ì„ ë¹¼ì„œ 'ì–´ë””ë¡œ' ë†“ëŠ”ì§€ ì¡°í•©ì´ ë„ˆë¬´ ë§ìŒ.
                    // í˜„ì¬ í•™ìŠµëœ ëª¨ë¸ì€ 'ë°°ì¹˜(Place)'ì— íŠ¹í™”ëœ 200ê°œ ì¶œë ¥ë§Œ ê°€ì§.
                    // ì´ë™ ë‹¨ê³„ì¼ ë•ŒëŠ” MCTS ë¡œì§ì´ë‚˜ ëœë¤, í˜¹ì€ íœ´ë¦¬ìŠ¤í‹±ì„ ì¨ì•¼ í•¨.
                    // **ì¤‘ìš”**: 5ì„¸ëŒ€ AIëŠ” MaskablePPOë¡œ 'ì´ë™'ê¹Œì§€ í•™ìŠµí–ˆë‚˜ìš”?
                    // ë³´í†µ ì˜¤ëª© AIëŠ” 'ì°©ìˆ˜'ë§Œ í•™ìŠµí•©ë‹ˆë‹¤. 
                    // ì´ë™ ë‹¨ê³„ë¼ë©´ AIê°€ ì‘ë™í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìœ¼ë‹ˆ, ì´ë™ì€ ëœë¤ì´ë‚˜ MCTSë¡œ ëŒ€ì²´.
                    return validMoves[Math.floor(Math.random() * validMoves.length)];
                }

                if (validActionIndices.length === 0) return null;

                // --- ì‹ ê²½ë§ ì—°ì‚° ì‹œì‘ ---
                const obs = this.getObservation(logic, player);
                
                // Layer 1
                let h1 = this.matMul(obs, this.weights.fc0_w, this.weights.fc0_b);
                for(let k=0; k<h1.length; k++) h1[k] = Math.tanh(h1[k]); // Activation

                // Layer 2
                let h2 = this.matMul(h1, this.weights.fc1_w, this.weights.fc1_b);
                for(let k=0; k<h2.length; k++) h2[k] = Math.tanh(h2[k]);

                // Output Layer
                const logits = this.matMul(h2, this.weights.fc2_w, this.weights.fc2_b);

                // Argmax with Masking
                let bestIdx = -1;
                let maxVal = -Infinity;

                for (let idx of validActionIndices) {
                    if (logits[idx] > maxVal) {
                        maxVal = logits[idx];
                        bestIdx = idx;
                    }
                }

                if (bestIdx !== -1) return actionToMoveObj[bestIdx];
                return validMoves[0]; // fallback
            }
        }

        function getCellsFromBase(bx, by, shapeIdx) {
            const shape = SHAPES[shapeIdx];
            return shape.map(d => ({x: bx + d.x, y: by + d.y, z: d.z}));
        }

        const SHAPES = [
            [{x:0,y:0,z:0}, {x:1,y:0,z:0}, {x:0,y:1,z:0}], [{x:0,y:0,z:0}, {x:1,y:0,z:0}, {x:0,y:-1,z:0}],
            [{x:0,y:0,z:0}, {x:-1,y:0,z:0}, {x:0,y:-1,z:0}], [{x:0,y:0,z:0}, {x:-1,y:0,z:0}, {x:0,y:1,z:0}],
            [{x:0,y:0,z:0}, {x:0,y:0,z:1}, {x:1,y:0,z:1}], [{x:0,y:0,z:0}, {x:0,y:0,z:1}, {x:-1,y:0,z:1}],
            [{x:0,y:0,z:0}, {x:0,y:0,z:1}, {x:0,y:1,z:1}], [{x:0,y:0,z:0}, {x:0,y:0,z:1}, {x:0,y:-1,z:1}]
        ];

        // ==========================================
        // Game Logic & Setup
        // ==========================================
        class GameLogic {
            constructor() { this.reset(); }
            reset() {
                this.board = Array.from({length: 5}, () => Array.from({length: 5}, () => Array(5).fill(0)));
                this.blocks = []; this.history = []; this.turnCount = 0; this.currentPlayer = 1;
                this.blocksLeft = { 1: 4, 2: 4 }; this.phase = 'PLACEMENT'; this.winner = 0;
                this.initFixedBlocks(); this.aiMode = true;
                this.selectedBlock = null; this.selectedBlockOriginalCells = null;
            }
            initFixedBlocks() {
                this.blocks = []; this.board = Array.from({length: 5}, () => Array.from({length: 5}, () => Array(5).fill(0)));
                // ê³ ì • ë¸”ë¡ (ê·œì¹™)
                this.addBlock(1, [{x:1, y:3, z:0}, {x:2, y:3, z:0}, {x:1, y:2, z:0}], 0, true);
                this.addBlock(2, [{x:2, y:1, z:0}, {x:3, y:1, z:0}, {x:3, y:2, z:0}], 0, true);
            }
            addBlock(player, cells, shapeIdx, isFixed=false) {
                const blockId = Date.now() + Math.random();
                this.blocks.push({ id: blockId, player, cells, shapeIdx, isFixed });
                cells.forEach(c => this.board[c.z][c.y][c.x] = player);
            }
            removeBlock(blockId) {
                const idx = this.blocks.findIndex(b => b.id === blockId);
                if (idx > -1) {
                    const block = this.blocks[idx];
                    block.cells.forEach(c => this.board[c.z][c.y][c.x] = 0);
                    this.blocks.splice(idx, 1);
                    return block;
                }
                return null;
            }
            canPick(block) {
                if (block.isFixed) return false;
                for (let c of block.cells) {
                    if (c.z >= 4) continue;
                    if (this.board[c.z+1][c.y][c.x] !== 0) {
                        const isSelf = block.cells.some(sc => sc.x===c.x && sc.y===c.y && sc.z===c.z+1);
                        if (!isSelf) return false;
                    }
                }
                return true;
            }
            pickBlock(x, y, z) {
                const block = this.blocks.find(b => b.player === this.currentPlayer && !b.isFixed && b.cells.some(c => c.x===x && c.y===y && c.z===z));
                if (!block) return { ok: false, msg: "ë‚´ ë¸”ë¡ ì•„ë‹˜" };
                if (!this.canPick(block)) return { ok: false, msg: "ë¶ˆê°€: ìœ„ì— ë¸”ë¡ ìˆìŒ" };
                this.saveState();
                this.selectedBlockOriginalCells = JSON.parse(JSON.stringify(block.cells));
                this.removeBlock(block.id);
                this.selectedBlock = block;
                return { ok: true, block: block };
            }
            checkValidity(player, cells, isMovement=false, originalCells=null) {
                if (this.winner !== 0) return { ok: false, msg: "ê²Œì„ ì¢…ë£Œë¨" };
                const origin = originalCells || (isMovement && this.selectedBlockOriginalCells ? this.selectedBlockOriginalCells : null);
                if (isMovement && origin) {
                    const cSet = new Set(cells.map(c=>`${c.x},${c.y},${c.z}`));
                    const oSet = new Set(origin.map(c=>`${c.x},${c.y},${c.z}`));
                    if (cSet.size === oSet.size) {
                        let same = true; 
                        for(let k of cSet) if(!oSet.has(k)) { same=false; break; }
                        if(same) return { ok:false, msg:"ì œìë¦¬ ë¶ˆê°€" };
                    }
                }
                for(let c of cells) {
                    if(c.x<0||c.x>4||c.y<0||c.y>4||c.z<0||c.z>4) return {ok:false, msg:"ë²”ìœ„ ì´ˆê³¼"};
                    if(this.board[c.z][c.y][c.x]!==0) return {ok:false, msg:"ì´ë¯¸ ìˆìŒ"};
                }
                if (!isMovement && this.turnCount < 2) {
                    const restricted = ["0,3","0,4","1,4","3,0","4,0","4,1"];
                    if(cells.some(c=>c.z===0 && restricted.includes(`${c.x},${c.y}`))) return {ok:false, msg:"ê¸ˆì§€ êµ¬ì—­"};
                }
                if ([1,3].indexOf(cells.filter(c=>c.z===0).length) === -1) return {ok:false, msg:"ì ‘ì§€ ìœ„ë°˜"};
                for(let c of cells) {
                    if(c.z>0) {
                        const hasSup = this.board[c.z-1][c.y][c.x]!==0;
                        const isSelf = cells.some(sc=>sc.x===c.x && sc.y===c.y && sc.z===c.z-1);
                        if(!hasSup && !isSelf) return {ok:false, msg:"ì§€ì§€ëŒ€ í•„ìš”"};
                    }
                }
                return {ok:true};
            }
            confirmMove(cells, shapeIdx) {
                if (this.phase === 'PLACEMENT') {
                    this.saveState();
                    this.addBlock(this.currentPlayer, cells, shapeIdx);
                    this.blocksLeft[this.currentPlayer]--;
                } else {
                    this.addBlock(this.currentPlayer, cells, shapeIdx);
                    this.selectedBlock = null; this.selectedBlockOriginalCells = null;
                }
                this.winner = this.checkWin();
                if (this.winner === 0) {
                    this.turnCount++;
                    this.currentPlayer = this.currentPlayer===1 ? 2:1;
                    if (this.blocksLeft[1] === 0 && this.blocksLeft[2] === 0) this.phase = 'MOVEMENT';
                    else if (this.blocksLeft[this.currentPlayer] === 0 && this.phase === 'PLACEMENT') this.phase = 'MOVEMENT';
                    
                    if(this.aiMode && this.currentPlayer !== myPlayerNum) setTimeout(runAI, 100);
                }
                return this.winner;
            }
            checkWin() {
                const topMap = Array.from({length: 5}, () => Array(5).fill(0));
                for(let y=0; y<5; y++) for(let x=0; x<5; x++) for(let z=4; z>=0; z--) if(this.board[z][y][x]!==0) { topMap[y][x]=this.board[z][y][x]; break; }
                const dirs = [{dx:1, dy:0}, {dx:0, dy:1}, {dx:1, dy:1}, {dx:1, dy:-1}];
                for(let y=0; y<5; y++) for(let x=0; x<5; x++) {
                    let c = topMap[y][x]; if(c===0) continue;
                    for(let d of dirs) {
                        let cnt=1; for(let k=1; k<5; k++) {
                            let nx=x+d.dx*k, ny=y+d.dy*k;
                            if(nx>=0&&nx<5&&ny>=0&&ny<5&&topMap[ny][nx]===c) cnt++; else break;
                        }
                        if(cnt===5) return c;
                    }
                }
                return 0;
            }
            saveState() { const s = { board: JSON.parse(JSON.stringify(this.board)), blocks: JSON.parse(JSON.stringify(this.blocks)), turnCount: this.turnCount, currentPlayer: this.currentPlayer, blocksLeft: {...this.blocksLeft}, phase: this.phase, winner: this.winner }; this.history.push(s); }
            undo() { if(this.history.length===0) return false; const s = this.history.pop(); Object.assign(this, s); this.selectedBlock=null; this.selectedBlockOriginalCells=null; return true; }
        }

        // AI Helper for Movement Phase (Random Fallback)
        function getAllValidMoves(g, p) {
            const moves = [];
            if (g.blocksLeft[p] > 0) {
                // ì´ í•¨ìˆ˜ëŠ” AI í´ë˜ìŠ¤ ë‚´ë¶€ì—ì„œ ë‹¤ì‹œ ê³„ì‚°í•˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ë¹ˆ ë°°ì—´ ë¦¬í„´í•´ë„ ë¨.
                // í•˜ì§€ë§Œ ì´ë™ ë‹¨ê³„ í´ë°±ì„ ìœ„í•´ ë‚¨ê²¨ë‘ .
                for (let x=0; x<5; x++) for (let y=0; y<5; y++) for (let s=0; s<8; s++) {
                    const sh = SHAPES[s]; const cells = sh.map(d => ({x:x+d.x, y:y+d.y, z:d.z}));
                    if (g.checkValidity(p, cells).ok) moves.push({ type:'place', cells, shapeIdx: s });
                }
            } else {
                const myBlocks = g.blocks.filter(b => b.player === p && !b.isFixed);
                for (let b of myBlocks) {
                    if (!g.canPick(b)) continue;
                    const orig = JSON.parse(JSON.stringify(b.cells));
                    g.removeBlock(b.id);
                    for (let x=0; x<5; x++) for (let y=0; y<5; y++) for (let s=0; s<8; s++) {
                        const sh = SHAPES[s]; const cells = sh.map(d => ({x:x+d.x, y:y+d.y, z:d.z}));
                        if (g.checkValidity(p, cells, true, orig).ok) {
                            moves.push({ type:'move', fromId:b.id, cells, shapeIdx: s });
                        }
                    }
                    g.addBlock(p, orig, b.shapeIdx, false);
                    g.blocks[g.blocks.length-1].id = b.id;
                }
            }
            return moves;
        }

        // ==========================================
        // Main Setup
        // ==========================================
        const logic = new GameLogic();
        const logEl = document.getElementById('log-console');
        const aiLoader = document.getElementById('ai-loader');
        let ai = null;

        function log(msg) { 
            const div = document.createElement('div'); div.innerText = `> ${msg}`;
            logEl.insertBefore(div, logEl.firstChild);
            if(logEl.children.length > 4) logEl.removeChild(logEl.lastChild);
        }

        // File Upload Handler
        window.loadBrain = (input) => {
            const file = input.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const weights = JSON.parse(e.target.result);
                    ai = new NeuralAI(weights);
                    document.getElementById('brain-status').innerText = "âœ… AI ì¥ì°© ì™„ë£Œ (Neural v5)";
                    document.getElementById('brain-status').style.color = "#2ecc71";
                    alert("AI ë‡Œê°€ ì„±ê³µì ìœ¼ë¡œ ì´ì‹ë˜ì—ˆìŠµë‹ˆë‹¤! ì´ì œ ë˜‘ë˜‘í•©ë‹ˆë‹¤.");
                } catch(err) {
                    alert("JSON íŒŒì¼ì´ ì´ìƒí•©ë‹ˆë‹¤. ë‹¤ì‹œ ë‹¤ìš´ë¡œë“œ ë°›ì•„ì£¼ì„¸ìš”.");
                }
            };
            reader.readAsText(file);
        };

        // Three.js Setup
        const scene = new THREE.Scene(); scene.background = new THREE.Color(0xdfe4ea);
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
        camera.position.set(0, 14, 12); camera.lookAt(0,0,0);
        const renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('game-canvas').appendChild(renderer.domElement);
        
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7); dirLight.position.set(5,15,5); dirLight.castShadow=true; scene.add(dirLight);
        const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping=true; controls.maxPolarAngle=Math.PI/2;
        
        const boardGroup = new THREE.Group(); scene.add(boardGroup);
        const ghostGroup = new THREE.Group(); scene.add(ghostGroup);
        const hintGroup = new THREE.Group(); scene.add(hintGroup);
        
        const hitPlane = new THREE.Mesh(new THREE.PlaneGeometry(6,6), new THREE.MeshBasicMaterial({ visible:false, side:THREE.DoubleSide }));
        hitPlane.rotation.x=-Math.PI/2; hitPlane.position.y=0.5; scene.add(hitPlane);
        scene.add(new THREE.GridHelper(5,5, 0xbdc3c7, 0xecf0f1));
        const basePlate = new THREE.Mesh(new THREE.BoxGeometry(5,0.1,5), new THREE.MeshStandardMaterial({color:0xdeb887}));
        basePlate.position.y=-0.05; basePlate.receiveShadow=true; scene.add(basePlate);

        let currentShapeIdx=0, hoverX=-1, hoverY=-1, hoveredBlockId=null;

        function updateUI() {
            document.getElementById('p1-cnt').innerText = logic.blocksLeft[1];
            document.getElementById('p2-cnt').innerText = logic.blocksLeft[2];
            document.getElementById('turn-indicator').innerText = logic.currentPlayer===1?"(í‘ ì°¨ë¡€)":"(ë°± ì°¨ë¡€)";
            document.getElementById('turn-indicator').style.color = logic.currentPlayer===1?"#e74c3c":"#2ecc71";
            document.getElementById('game-phase').innerText = logic.phase==='MOVEMENT'?"ì´ë™":"ì°©ìˆ˜";
            document.getElementById('game-phase').style.background = logic.phase==='MOVEMENT'?"#e67e22":"#333";
            
            const btn = document.getElementById('btn-ai-toggle');
            btn.innerText = logic.aiMode ? "ğŸ¤– AI ëŒ€ì „: ON" : "ğŸ¤– AI ëŒ€ì „: OFF";
            logic.aiMode ? btn.classList.add('active') : btn.classList.remove('active');
        }

        function renderBoard() {
            for(let i=boardGroup.children.length-1; i>=0; i--) boardGroup.remove(boardGroup.children[i]);
            const geo = new RoundedBoxGeometry(0.98,0.98,0.98, 4, 0.1);
            logic.blocks.forEach(b => {
                const isHov = b.id===hoveredBlockId;
                const col = b.player===1 ? (isHov?0x555555:0x333333) : (isHov?0xffffff:0xeeeeee);
                const mat = new THREE.MeshStandardMaterial({color:col, roughness:0.3});
                const grp = new THREE.Group(); grp.userData={id:b.id, isBlock:true};
                b.cells.forEach(c=>{
                    const m = new THREE.Mesh(geo, mat); m.position.set(c.x-2, c.z+0.5, c.y-2);
                    m.castShadow=true; m.receiveShadow=true; m.userData={id:b.id, parentGroup:grp}; grp.add(m);
                });
                // Connectors visual
                for(let i=0; i<b.cells.length; i++) for(let j=i+1; j<b.cells.length; j++) {
                    const c1=b.cells[i], c2=b.cells[j];
                    if(Math.abs(c1.x-c2.x)+Math.abs(c1.y-c2.y)+Math.abs(c1.z-c2.z)===1) {
                        let bg; 
                        if(Math.abs(c1.x-c2.x)===1) bg=new THREE.BoxGeometry(1,0.8,0.8);
                        else if(Math.abs(c1.y-c2.y)===1) bg=new THREE.BoxGeometry(0.8,0.8,1);
                        else bg=new THREE.BoxGeometry(0.8,1,0.8);
                        const br=new THREE.Mesh(bg, mat); br.position.set((c1.x+c2.x)/2-2, (c1.z+c2.z)/2+0.5, (c1.y+c2.y)/2-2);
                        grp.add(br);
                    }
                }
                boardGroup.add(grp);
            });
        }

        function updateGhost() {
            while(ghostGroup.children.length>0) ghostGroup.remove(ghostGroup.children[0]);
            if(logic.winner!==0) return;
            if(logic.aiMode && logic.currentPlayer!==myPlayerNum) return;
            if(logic.phase==='MOVEMENT' && !logic.selectedBlock) return;
            if(hoverX===-1) return;
            const sh = SHAPES[currentShapeIdx%8];
            const cells = sh.map(c=>({x:hoverX+c.x, y:hoverY+c.y, z:c.z}));
            const chk = logic.checkValidity(logic.currentPlayer, cells, logic.phase==='MOVEMENT');
            drawGhost(cells, chk.ok?0x2ecc71:0xe74c3c, ghostGroup, 0.6);
        }

        function drawGhost(cells, col, grp, op) {
            const mat = new THREE.MeshBasicMaterial({color:col, transparent:true, opacity:op});
            const geo = new RoundedBoxGeometry(0.96,0.96,0.96, 4, 0.1);
            cells.forEach(c=>{
                const m = new THREE.Mesh(geo, mat); m.position.set(c.x-2, c.z+0.52, c.y-2);
                grp.add(m);
            });
        }

        window.showSideSelection = () => {
            document.getElementById('lobby-main').style.display='none';
            document.getElementById('lobby-side').style.display='block';
        };

        window.startSingleGame = (playerNum) => {
            myPlayerNum = playerNum; 
            document.getElementById('lobby-overlay').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'flex';
            
            const badge = document.getElementById('my-player-badge');
            badge.innerText = playerNum===1 ? "ğŸ‘¤ ë‚˜: í‘ (ì„ ê³µ)" : "ğŸ‘¤ ë‚˜: ë°± (í›„ê³µ)";
            badge.style.background = playerNum===1 ? "#333" : "#9b59b6";
            
            logic.aiMode = true; 
            updateUI();

            if(myPlayerNum === 2) setTimeout(runAI, 500); 
        };

        async function runAI() {
            if(!ai || !ai.ready) {
                if(confirm("AI ë‡Œ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤. ì§€ê¸ˆ ì—…ë¡œë“œ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
                    document.getElementById('brain-upload').click();
                } else {
                    log("AIê°€ ì—†ìŠµë‹ˆë‹¤. ê·¸ëƒ¥ í„´ì„ ë„˜ê¸°ê±°ë‚˜ ì§ì ‘ ë‘ì„¸ìš”.");
                }
                return;
            }

            aiLoader.style.display = 'block';
            
            // UI Blocking delay slightly
            setTimeout(() => {
                const move = ai.getBestMove(logic, logic.currentPlayer);
                aiLoader.style.display = 'none';

                if(move) {
                    if(move.type==='place') logic.confirmMove(move.cells, move.shapeIdx);
                    else {
                        const b = logic.blocks.find(x=>x.id===move.fromId);
                        if(b) {
                            logic.selectedBlockOriginalCells = JSON.parse(JSON.stringify(b.cells));
                            logic.removeBlock(b.id); logic.selectedBlock = b;
                            logic.confirmMove(move.cells, move.shapeIdx);
                        }
                    }
                    log("AI(ì‹ ê²½ë§) ì°©ìˆ˜ ì™„ë£Œ"); renderBoard(); updateUI(); updateGhost();
                    if(logic.winner!==0) setTimeout(() => alert(`ê²Œì„ ì¢…ë£Œ! Player ${logic.winner} ìŠ¹ë¦¬!`), 200);
                } else {
                    log("AI ê¸°ê¶Œ (ë‘˜ ê³³ ì—†ìŒ)");
                }
            }, 50);
        }

        window.toggleAIMode = () => {
            logic.aiMode = !logic.aiMode; updateUI();
            if(logic.aiMode && logic.currentPlayer !== myPlayerNum) runAI();
        };
        window.undo = () => { if(logic.undo()) { log("ë¬´ë¥´ê¸°"); hoveredBlockId=null; while(hintGroup.children.length>0) hintGroup.remove(hintGroup.children[0]); renderBoard(); updateUI(); } };
        window.resetGame = () => { if(confirm("ì´ˆê¸°í™”?")) { logic.reset(); hoveredBlockId=null; while(hintGroup.children.length>0) hintGroup.remove(hintGroup.children[0]); renderBoard(); updateUI(); log("ì´ˆê¸°í™”ë¨"); } };
        window.askAI = () => {
            if(!ai || !ai.ready) { alert("JSON íŒŒì¼ ë¨¼ì € ì—…ë¡œë“œí•˜ì„¸ìš”!"); return; }
            const move = ai.getBestMove(logic, logic.currentPlayer);
            if(move) {
                while(hintGroup.children.length>0) hintGroup.remove(hintGroup.children[0]);
                drawGhost(move.cells, 0xf1c40f, hintGroup, 0.8);
                log("ğŸ’¡ íŒíŠ¸ í‘œì‹œë¨");
            }
        };
        
        document.onkeydown = (e) => {
            if(e.code==='KeyR') { currentShapeIdx++; updateGhost(); }
            if(e.code==='KeyZ') window.undo();
        };
        
        document.getElementById('btn-rotate').addEventListener('click', e=>{ e.stopPropagation(); currentShapeIdx++; updateGhost(); });
        window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        
        const ray = new THREE.Raycaster(); const mouse = new THREE.Vector2(); let downTime=0;
        window.addEventListener('mousemove', e=>{
            mouse.x=(e.clientX/window.innerWidth)*2-1; mouse.y=-(e.clientY/window.innerHeight)*2+1;
            ray.setFromCamera(mouse, camera);
            if(logic.aiMode && logic.currentPlayer!==myPlayerNum) return;
            if(logic.phase==='MOVEMENT' && !logic.selectedBlock) {
                const ints = ray.intersectObjects(boardGroup.children, true);
                if(ints.length>0) {
                    const bid = ints[0].object.userData.id;
                    if(bid && bid!==hoveredBlockId) { hoveredBlockId=bid; renderBoard(); }
                    hoverX=-1; updateGhost(); return;
                } else if(hoveredBlockId!==null) { hoveredBlockId=null; renderBoard(); }
            }
            const ints = ray.intersectObject(hitPlane);
            if(ints.length>0) {
                const p=ints[0].point; const gx=Math.floor(p.x+2.5), gy=Math.floor(p.z+2.5);
                if(gx>=0&&gx<5&&gy>=0&&gy<5) {
                    if(hoverX!==gx||hoverY!==gy) { hoverX=gx; hoverY=gy; updateGhost(); }
                } else { hoverX=-1; updateGhost(); }
            } else { hoverX=-1; updateGhost(); }
        });
        window.addEventListener('mousedown', ()=>downTime=Date.now());
        window.addEventListener('mouseup', ()=>{ if(Date.now()-downTime<250) click(); });
        
        function click() {
            if(logic.winner!==0) return;
            if(logic.aiMode && logic.currentPlayer!==myPlayerNum) { log("ìƒëŒ€ë°© í„´ì…ë‹ˆë‹¤."); return; }
            while(hintGroup.children.length>0) hintGroup.remove(hintGroup.children[0]);

            if(logic.phase==='MOVEMENT' && !logic.selectedBlock) {
                if(hoveredBlockId) {
                    const b = logic.blocks.find(x=>x.id===hoveredBlockId);
                    if(b) {
                        const res = logic.pickBlock(b.cells[0].x, b.cells[0].y, b.cells[0].z);
                        if(res.ok) { log("ë¸”ë¡ ì„ íƒë¨"); currentShapeIdx=res.block.shapeIdx; hoveredBlockId=null; renderBoard(); }
                        else log(res.msg);
                    }
                }
                return;
            }
            if(hoverX!==-1) {
                const sh = SHAPES[currentShapeIdx%8];
                const cells = sh.map(c=>({x:hoverX+c.x, y:hoverY+c.y, z:c.z}));
                const chk = logic.checkValidity(logic.currentPlayer, cells, logic.phase==='MOVEMENT');
                if(chk.ok) {
                    logic.confirmMove(cells, currentShapeIdx%8);
                    log("ì°©ìˆ˜ ì™„ë£Œ"); renderBoard(); updateUI(); updateGhost();
                    if(logic.winner!==0) setTimeout(() => alert(`ê²Œì„ ì¢…ë£Œ! Player ${logic.winner} ìŠ¹ë¦¬!`), 200);
                } else log(chk.msg);
            }
        }
        
        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
        renderBoard(); updateUI(); animate();
    </script>
</body>
</html>