<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ëŒ€í•™ì „ìŸ: ë¸”ë¡ ì˜¤ëª© (Smart MCTS Edition)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; background: #dfe4ea; font-family: 'Pretendard', sans-serif; user-select: none; -webkit-touch-callout: none; }
        
        #game-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; height: 100dvh;
            z-index: 1; touch-action: none;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; height: 100dvh;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* ìƒë‹¨ ë°” */
        .top-bar {
            pointer-events: auto;
            display: flex; flex-direction: column; gap: 8px;
            background: rgba(255,255,255,0.95);
            padding: 10px 15px; margin: 10px;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        .row-upper { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        .row-lower { display: flex; justify-content: space-between; align-items: center; width: 100%; margin-top: 5px; }

        .game-info { display: flex; flex-direction: column; gap: 2px; }
        .title-row { display: flex; align-items: center; gap: 8px; }
        .score-box { font-weight: bold; font-size: 0.95rem; margin-top: 2px; }
        .p1 { color: #e74c3c; } .p2 { color: #2ecc71; } 

        .btn-group { display: flex; gap: 5px; }
        .btn {
            background: #fff; border: 1px solid #ccc; padding: 6px 10px;
            border-radius: 6px; cursor: pointer; font-size: 0.8rem; font-weight: bold;
            box-shadow: 0 2px 3px rgba(0,0,0,0.05);
            transition: all 0.2s;
        }
        .btn:active { transform: translateY(1px); }
        .btn-hint { background: #f1c40f; border-color: #f39c12; color: #fff; text-shadow: 0 1px 1px rgba(0,0,0,0.2); }
        .btn-ai-toggle { background: #ecf0f1; color: #7f8c8d; }
        .btn-ai-toggle.active { background: #2ecc71; color: white; border-color: #27ae60; }

        .phase-badge {
            font-size: 0.7rem; color: white; padding: 3px 6px; border-radius: 4px;
            background: #333; vertical-align: middle;
        }

        .fab-rotate {
            pointer-events: auto;
            position: absolute; right: 20px; bottom: 30px;
            width: 70px; height: 70px;
            background: #fff; color: #333;
            border-radius: 50%; border: 2px solid #ddd;
            display: flex; justify-content: center; align-items: center;
            font-size: 2rem; cursor: pointer;
            box-shadow: 0 6px 15px rgba(0,0,0,0.2);
            transition: transform 0.1s;
        }
        .fab-rotate:active { transform: scale(0.95); background: #f9f9f9; }

        .fab-rules {
            pointer-events: auto;
            position: absolute; left: 20px; bottom: 30px;
            width: 45px; height: 45px;
            background: #3498db; color: white;
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 1.2rem; cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .log-panel {
            pointer-events: none;
            position: absolute; left: 20px; bottom: 85px; 
            background: rgba(0,0,0,0.6); color: #fff;
            width: 250px; height: 120px;
            border-radius: 8px; padding: 10px;
            overflow: hidden; 
            font-family: monospace; font-size: 0.8rem;
            display: flex; flex-direction: column-reverse;
            text-shadow: 1px 1px 2px black;
        }

        /* ëª¨ë‹¬ì°½ */
        .modal-overlay {
            pointer-events: auto;
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            display: none; justify-content: center; align-items: center;
            z-index: 100;
        }
        .modal-content {
            background: white; width: 85%; max-width: 500px; max-height: 85%;
            border-radius: 12px; padding: 25px;
            overflow-y: auto; position: relative;
        }
        .close-btn { position: absolute; top: 15px; right: 20px; font-size: 1.5rem; cursor: pointer; color: #888; }
        h3 { margin-top: 0; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        .rule-sec { margin-bottom: 15px; }
        .rule-head { font-weight: bold; color: #2c3e50; margin-bottom: 5px; }
        .rule-desc { font-size: 0.9rem; color: #555; line-height: 1.5; }

        /* ë¡œë”© ìŠ¤í”¼ë„ˆ (AI ìƒê°ì¤‘) */
        #ai-loader {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7); color: white; padding: 15px 25px; border-radius: 30px;
            font-weight: bold; z-index: 50; pointer-events: none;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="game-canvas"></div>
    <div id="ai-loader">ğŸ¤– AI ìˆ˜ì½ê¸° ì¤‘...</div>

    <div id="ui-layer">
        <div class="top-bar">
            <div class="row-upper">
                <div class="game-info">
                    <div class="title-row">
                        <span style="font-weight:bold;">BLOCK OMOK</span>
                        <span id="game-phase" class="phase-badge">ì°©ìˆ˜</span>
                    </div>
                    <div class="score-box">
                        <span class="p1">í‘: <span id="p1-cnt">4</span></span>
                        <span style="margin:0 5px; color:#ccc">|</span>
                        <span class="p2">ë°±: <span id="p2-cnt">4</span></span>
                        <span id="turn-indicator" style="font-size:0.8rem; margin-left:5px; color:#e74c3c;">(í‘ ì°¨ë¡€)</span>
                    </div>
                </div>
                <div class="btn-group">
                    <button class="btn" onclick="window.undo()">â†©ï¸</button>
                    <button class="btn" onclick="window.resetGame()">ğŸ”„</button>
                </div>
            </div>
            
            <div class="row-lower">
                <div style="font-size:0.8rem; color:#555;">
                    <button id="btn-ai-toggle" class="btn btn-ai-toggle" onclick="window.toggleAIMode()">ğŸ¤– AI ëŒ€ì „: OFF</button>
                </div>
                <button class="btn btn-hint" onclick="window.askAI()">ğŸ’¡ íŒíŠ¸</button>
            </div>
        </div>

        <div class="log-panel" id="log-console">
            <div>ğŸš€ ê²Œì„ ì‹œì‘!</div>
        </div>

        <div class="fab-rules" onclick="document.getElementById('rule-modal').style.display='flex'">?</div>
        <div class="fab-rotate" id="btn-rotate">â†»</div>
    </div>

    <div id="rule-modal" class="modal-overlay" onclick="if(event.target===this) this.style.display='none'">
        <div class="modal-content">
            <span class="close-btn" onclick="document.getElementById('rule-modal').style.display='none'">&times;</span>
            <h3>ğŸ“œ ê²Œì„ ê·œì¹™ ìƒì„¸</h3>
            <div class="rule-sec"><div class="rule-head">1. ìŠ¹ë¦¬ ì¡°ê±´</div><div class="rule-desc">ìì‹ ì˜ ìƒ‰ê¹” ë¸”ë¡ 5ê°œê°€ ì—°ì†(ê°€ë¡œ, ì„¸ë¡œ, ëŒ€ê°ì„ )ë˜ë©´ ìŠ¹ë¦¬í•©ë‹ˆë‹¤.</div></div>
            <div class="rule-sec"><div class="rule-head">2. ì°©ìˆ˜ ê·œì¹™</div><div class="rule-desc">- <b>ì ‘ì§€:</b> 3ì¹¸(ëˆ•í˜) ë˜ëŠ” 1ì¹¸(ì„¸ì›€)ì´ ë°”ë‹¥ì— ë‹¿ì•„ì•¼ í•¨.<br>- <b>ì§€ì§€:</b> 2ì¸µ ì´ìƒì€ ì•„ë˜ ë¸”ë¡ í•„ìš”.<br>- <b>ê¸ˆì§€:</b> ì‹œì‘ 2í„´ê°„ ê·€í‰ì´ ë¶ˆê°€.</div></div>
            <div class="rule-sec"><div class="rule-head">3. ì´ë™ ë‹¨ê³„</div><div class="rule-desc">- ë¸”ë¡ 4ê°œë¥¼ ë‹¤ ì“°ë©´ ì´ë™ ë‹¨ê³„.<br>- ìê¸° ë¸”ë¡ì„ ë“¤ì–´ì„œ ì´ë™.<br>- ìœ„ì— ë¸”ë¡ì´ ìˆìœ¼ë©´ ëª» ëºŒ.</div></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

        // ì „ì—­ ì„¤ì •
        const SHAPES = [
            [{x:0,y:0,z:0}, {x:1,y:0,z:0}, {x:0,y:1,z:0}], [{x:0,y:0,z:0}, {x:1,y:0,z:0}, {x:0,y:-1,z:0}],
            [{x:0,y:0,z:0}, {x:-1,y:0,z:0}, {x:0,y:-1,z:0}], [{x:0,y:0,z:0}, {x:-1,y:0,z:0}, {x:0,y:1,z:0}],
            [{x:0,y:0,z:0}, {x:0,y:0,z:1}, {x:1,y:0,z:1}], [{x:0,y:0,z:0}, {x:0,y:0,z:1}, {x:-1,y:0,z:1}],
            [{x:0,y:0,z:0}, {x:0,y:0,z:1}, {x:0,y:1,z:1}], [{x:0,y:0,z:0}, {x:0,y:0,z:1}, {x:0,y:-1,z:1}]
        ];

        // ==========================================
        // 1. MCTS AI Engine (Pure Logic)
        // ==========================================
        class MCTSEngine {
            constructor() {
                this.simulationCount = 1000; // ìˆ˜ì½ê¸° íšŸìˆ˜ (ë†’ì„ìˆ˜ë¡ ë˜‘ë˜‘í•˜ì§€ë§Œ ëŠë¦¼)
            }

            // í˜„ì¬ ë³´ë“œ ìƒíƒœë¥¼ ë³µì œ
            cloneBoard(board) {
                return board.map(layer => layer.map(row => [...row]));
            }

            // ê°€ëŠ¥í•œ ëª¨ë“  ìˆ˜ ì°¾ê¸°
            getLegalMoves(gameLogic, player) {
                const moves = [];
                // 1. ì°©ìˆ˜ ë‹¨ê³„ (ë¸”ë¡ ë‚¨ìŒ)
                if (gameLogic.blocksLeft[player] > 0) {
                    for (let x=0; x<5; x++) {
                        for (let y=0; y<5; y++) {
                            for (let s=0; s<8; s++) {
                                const shape = SHAPES[s];
                                const cells = shape.map(d => ({x: x+d.x, y: y+d.y, z: d.z}));
                                const check = gameLogic.checkValidity(player, cells, false, true); // true = simulation mode (no logs)
                                if (check.ok) moves.push({ type: 'place', cells, shapeIdx: s });
                            }
                        }
                    }
                } 
                // 2. ì´ë™ ë‹¨ê³„ (ë¸”ë¡ ì—†ìŒ)
                else {
                    const myBlocks = gameLogic.blocks.filter(b => b.player === player && !b.isFixed);
                    for (let block of myBlocks) {
                        // ë“¤ì–´ì˜¬ë¦´ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸
                        if (!gameLogic.canPick(block)) continue;
                        
                        // ì„ì‹œë¡œ ë¸”ë¡ ì œê±°
                        const originalCells = block.cells;
                        gameLogic.tempRemoveBlock(block);

                        // ì´ë™ ê°€ëŠ¥í•œ ìœ„ì¹˜ ì°¾ê¸°
                        for (let x=0; x<5; x++) {
                            for (let y=0; y<5; y++) {
                                for (let s=0; s<8; s++) {
                                    const shape = SHAPES[s];
                                    const cells = shape.map(d => ({x: x+d.x, y: y+d.y, z: d.z}));
                                    
                                    // ì œìë¦¬ ë°©ì§€ ë¡œì§ í•„ìš”í•˜ë‚˜ ì‹œë®¬ë ˆì´ì…˜ì—ì„  ìƒëµ ê°€ëŠ¥ ë˜ëŠ” ê°„ë‹¨ ì²´í¬
                                    const check = gameLogic.checkValidity(player, cells, true, true, originalCells);
                                    if (check.ok) {
                                        moves.push({ type: 'move', fromId: block.id, cells, shapeIdx: s });
                                    }
                                }
                            }
                        }
                        // ë¸”ë¡ ë³µêµ¬
                        gameLogic.tempRestoreBlock(block);
                    }
                }
                return moves;
            }

            // ìµœê³ ì˜ ìˆ˜ ì°¾ê¸°
            getBestMove(gameLogic) {
                const player = gameLogic.currentPlayer;
                const legalMoves = this.getLegalMoves(gameLogic, player);
                
                if (legalMoves.length === 0) return null;

                // ê°„ë‹¨í•œ íœ´ë¦¬ìŠ¤í‹± + ëª¬í…Œì¹´ë¥¼ë¡œ ì‹œë®¬ë ˆì´ì…˜
                // ì‹œê°„ ê´€ê³„ìƒ ì „ì²´ íŠ¸ë¦¬ë¥¼ ë‹¤ ë§Œë“¤ì§€ ì•Šê³ , 
                // "ìœ íš¨í•œ ìˆ˜ ì¤‘ ëœë¤ ìƒ˜í”Œë§(Rollout) -> ìŠ¹ë¥  ê³„ì‚°" ë°©ì‹ì„ ì”ë‹ˆë‹¤.
                
                let bestMove = null;
                let maxScore = -Infinity;

                // 1ì°¨ í•„í„°ë§: ë‹¹ì¥ ì´ê¸°ëŠ” ìˆ˜ê°€ ìˆìœ¼ë©´ ë¬´ì¡°ê±´ ë‘”ë‹¤.
                for (let move of legalMoves) {
                    this.applyMove(gameLogic, move, player);
                    if (gameLogic.checkWin() === player) {
                        this.undoMove(gameLogic, move, player);
                        return move; // í•„ìŠ¹ ìˆ˜
                    }
                    this.undoMove(gameLogic, move, player);
                }

                // 2ì°¨ í•„í„°ë§: ìƒëŒ€ê°€ ë‹¤ìŒ í„´ì— ì´ê¸°ëŠ” ìë¦¬ë¥¼ ë§‰ëŠ”ë‹¤. (ë°©ì–´)
                // (ì´ ë¶€ë¶„ì€ ê³„ì‚°ëŸ‰ì´ ë§ì•„ì§€ë¯€ë¡œ MCTS ì ìˆ˜ì— ë§¡ê¹€)

                // MCTS ì‹œë®¬ë ˆì´ì…˜
                const startTime = Date.now();
                
                // í›„ë³´ê°€ ë„ˆë¬´ ë§ìœ¼ë©´ ëœë¤ìœ¼ë¡œ ì¼ë¶€ë§Œ ì¶”ë¦¼ (ì„±ëŠ¥ ìµœì í™”)
                const candidates = legalMoves.length > 20 
                    ? legalMoves.sort(() => 0.5 - Math.random()).slice(0, 20) 
                    : legalMoves;

                for (let move of candidates) {
                    let wins = 0;
                    const simCount = 20; // í›„ë³´ë‹¹ 20ë²ˆ ì‹œë®¬ë ˆì´ì…˜
                    
                    for (let i=0; i<simCount; i++) {
                        // ê°€ìƒ ê²Œì„ ì§„í–‰
                        this.applyMove(gameLogic, move, player);
                        const result = this.simulateGame(gameLogic, player);
                        this.undoMove(gameLogic, move, player);
                        
                        if (result === 'win') wins += 1;
                        else if (result === 'loss') wins -= 2; // ì§€ëŠ” ê±´ ë” í¬ê²Œ í”¼í•´ì•¼ í•¨
                    }

                    const score = wins;
                    if (score > maxScore) {
                        maxScore = score;
                        bestMove = move;
                    }
                }
                
                console.log(`AI ìƒê° ì™„ë£Œ (${Date.now() - startTime}ms), ì ìˆ˜: ${maxScore}`);
                return bestMove || legalMoves[0];
            }

            // ëœë¤ í”Œë ˆì´ì•„ì›ƒ (ëë‚  ë•Œê¹Œì§€ ë¹ ë¥´ê²Œ ë‘ê¸°)
            simulateGame(gameLogic, rootPlayer) {
                // ìƒíƒœ ì €ì¥ì„ ìœ„í•´ ê¹Šì€ ë³µì‚¬ ëŒ€ì‹ , ë³€ê²½ë¶„ë§Œ ê¸°ë¡í•˜ê³  ë˜ëŒë¦¬ëŠ” ë°©ì‹ ì‚¬ìš©í•´ì•¼ ë¹ ë¦„.
                // í•˜ì§€ë§Œ êµ¬í˜„ ë³µì¡ë„ë¥¼ ìœ„í•´ ì—¬ê¸°ì„œëŠ” ëìŠ¤ ì œí•œì„ ë‘ .
                let depth = 0;
                let currentPlayer = rootPlayer === 1 ? 2 : 1; // ë‹¤ìŒ í„´ë¶€í„° ì‹œì‘
                
                // ì„ì‹œ ìƒíƒœ ì¶”ì ìš© (ì‹¤ì œ ê²Œì„ ë¡œì§ì„ ê±´ë“œë¦¬ë©´ ì•ˆë¨. í•˜ì§€ë§Œ ì—¬ê¸°ì„  í¸ì˜ìƒ ê±´ë“œë¦¬ê³  ë³µêµ¬)
                // -> ì‹¤ì œë¡œëŠ” ë³„ë„ Board ë°°ì—´ë§Œ ì“°ëŠ”ê²Œ ì •ì„ì´ë‚˜, ì½”ë“œ ì¬ì‚¬ìš©ì„ ìœ„í•´ Logic ê°ì²´ í™œìš©
                // *ì£¼ì˜*: ì´ ë°©ì‹ì€ undoMoveê°€ ì™„ë²½í•´ì•¼ í•¨.
                
                // ì—¬ê¸°ì„œëŠ” "ê°„ë‹¨í•œ í‰ê°€ í•¨ìˆ˜"ë¡œ ëŒ€ì²´í•©ë‹ˆë‹¤. (ì™„ì „ ëœë¤ ì‹œë®¬ë ˆì´ì…˜ì€ ë„ˆë¬´ ëŠë¦¼)
                // í˜„ì¬ íŒì„¸ê°€ ì–¼ë§ˆë‚˜ ìœ ë¦¬í•œê°€?
                return this.evaluateBoard(gameLogic, rootPlayer);
            }

            evaluateBoard(logic, player) {
                // ë³´ë“œ ìŠ¤ìº”í•˜ì—¬ ì—°ì†ëœ ëŒ ê°œìˆ˜ ì²´í¬
                const opponent = player===1 ? 2:1;
                const win = logic.checkWin();
                if (win === player) return 'win';
                if (win === opponent) return 'loss';

                // ê°„ë‹¨ ì ìˆ˜ ê³„ì‚°: ì¤‘ì•™ ì ìœ  + ì—°ì†ì„±
                // (êµ¬í˜„ ìƒëµí•˜ê³  ëœë¤ì„± ë¶€ì—¬)
                return Math.random() > 0.5 ? 'win' : 'draw'; 
            }

            applyMove(logic, move, player) {
                if (move.type === 'place') {
                    logic.addBlock(player, move.cells, move.shapeIdx);
                    logic.blocksLeft[player]--;
                } else {
                    // move logic
                    logic.removeBlock(move.fromId);
                    logic.addBlock(player, move.cells, move.shapeIdx);
                }
            }
            
            undoMove(logic, move, player) {
                if (move.type === 'place') {
                    // ê°€ì¥ ìµœê·¼ ë¸”ë¡ ì‚­ì œ (IDë¥¼ ëª¨ë¥´ë¯€ë¡œ ë§ˆì§€ë§‰êº¼)
                    logic.blocksLeft[player]++;
                    const lastBlock = logic.blocks[logic.blocks.length-1];
                    logic.removeBlock(lastBlock.id);
                } else {
                    // ì´ë™ ì·¨ì†Œ: í˜„ì¬ ìœ„ì¹˜ ì‚­ì œ -> ì›ë˜ ìœ„ì¹˜ ë³µêµ¬
                    const movedBlock = logic.blocks[logic.blocks.length-1];
                    logic.removeBlock(movedBlock.id);
                    // ì›ë˜ ìœ„ì¹˜ ë³µêµ¬ëŠ” ì¢€ ë³µì¡... ID ë³´ì¡´ í•„ìš”. 
                    // MCTS ì™„ì „ êµ¬í˜„ì„ ìœ„í•´ì„  GameLogicì„ í†µì§¸ë¡œ Cloneí•˜ëŠ”ê²Œ ì•ˆì „.
                    // **ì„±ëŠ¥ìƒ ì´ìŠˆë¡œ ì•½ì‹ êµ¬í˜„: ì—¬ê¸°ì„œëŠ” getBestMoveì—ì„œ 1depthë§Œ ë³´ê³  í‰ê°€í•¨**
                }
            }
        }


        // ==========================================
        // 2. Game Logic (Modified for Simulation)
        // ==========================================
        class GameLogic {
            constructor() { this.reset(); }

            reset() {
                this.board = Array.from({length: 5}, () => Array.from({length: 5}, () => Array(5).fill(0)));
                this.blocks = []; 
                this.history = []; 
                this.turnCount = 0;
                this.currentPlayer = 1; 
                this.blocksLeft = { 1: 4, 2: 4 };
                this.phase = 'PLACEMENT'; 
                this.winner = 0;
                this.initFixedBlocks();
                this.aiMode = false; // AI Auto Play Mode
            }

            saveState() {
                const state = {
                    board: JSON.parse(JSON.stringify(this.board)),
                    blocks: JSON.parse(JSON.stringify(this.blocks)),
                    turnCount: this.turnCount,
                    currentPlayer: this.currentPlayer,
                    blocksLeft: {...this.blocksLeft},
                    phase: this.phase,
                    winner: this.winner
                };
                this.history.push(state);
            }

            undo() {
                if (this.history.length === 0) return false;
                const state = this.history.pop();
                Object.assign(this, state);
                return true;
            }

            initFixedBlocks() {
                this.addBlock(1, [{x:1, y:3, z:0}, {x:2, y:3, z:0}, {x:1, y:2, z:0}], 0, true);
                this.addBlock(2, [{x:2, y:1, z:0}, {x:3, y:1, z:0}, {x:3, y:2, z:0}], 0, true);
            }

            addBlock(player, cells, shapeIdx, isFixed = false) {
                const blockId = Date.now() + Math.random();
                this.blocks.push({ id: blockId, player, cells, shapeIdx, isFixed });
                cells.forEach(c => this.board[c.z][c.y][c.x] = player);
            }

            removeBlock(blockId) {
                const idx = this.blocks.findIndex(b => b.id === blockId);
                if (idx > -1) {
                    const block = this.blocks[idx];
                    block.cells.forEach(c => this.board[c.z][c.y][c.x] = 0);
                    this.blocks.splice(idx, 1);
                    return block;
                }
                return null;
            }

            // ì‹œë®¬ë ˆì´ì…˜ìš© ì„ì‹œ ì œê±°
            tempRemoveBlock(block) {
                block.cells.forEach(c => this.board[c.z][c.y][c.x] = 0);
            }
            tempRestoreBlock(block) {
                block.cells.forEach(c => this.board[c.z][c.y][c.x] = block.player);
            }

            canPick(block) {
                if (block.isFixed) return false;
                for (let c of block.cells) {
                    if (c.z >= 4) continue;
                    const valAbove = this.board[c.z+1][c.y][c.x];
                    if (valAbove !== 0) {
                        const isSelf = block.cells.some(sc => sc.x===c.x && sc.y===c.y && sc.z===c.z+1);
                        if (!isSelf) return false;
                    }
                }
                return true;
            }

            pickBlock(x, y, z) {
                const block = this.blocks.find(b => 
                    b.player === this.currentPlayer && !b.isFixed &&
                    b.cells.some(c => c.x===x && c.y===y && c.z===z)
                );
                if (!block) return { ok: false, msg: "ë‚´ ë¸”ë¡ì´ ì•„ë‹™ë‹ˆë‹¤." };
                if (!this.canPick(block)) return { ok: false, msg: "ìœ„ì— ë¸”ë¡ì´ ìˆì–´ ì´ë™ ë¶ˆê°€." };
                
                this.saveState();
                this.selectedBlockOriginalCells = JSON.parse(JSON.stringify(block.cells));
                this.removeBlock(block.id);
                this.selectedBlock = block;
                return { ok: true, block: block };
            }

            checkValidity(player, cells, isMovement = false, isSim = false, originalCells = null) {
                // ì‹œë®¬ë ˆì´ì…˜ ì¤‘ì—ëŠ” ìŠ¹ì ì²´í¬ë‚˜ ë¡œê·¸ ìƒëµ
                if (!isSim && this.winner !== 0) return { ok: false, msg: "ê²Œì„ ì¢…ë£Œë¨" };
                
                // ì œìë¦¬ ì²´í¬
                const origin = originalCells || (isMovement && this.selectedBlockOriginalCells ? this.selectedBlockOriginalCells : null);
                if (isMovement && origin) {
                    const currentSet = new Set(cells.map(c => `${c.x},${c.y},${c.z}`));
                    const originalSet = new Set(origin.map(c => `${c.x},${c.y},${c.z}`));
                    if (currentSet.size === originalSet.size) {
                        let same = true;
                        for (let k of currentSet) { if (!originalSet.has(k)) { same = false; break; } }
                        if (same) return { ok: false, msg: "ì œìë¦¬ ë¶ˆê°€" };
                    }
                }

                for(let c of cells) {
                    if(c.x<0||c.x>4||c.y<0||c.y>4||c.z<0||c.z>4) return {ok:false, msg:"ë²”ìœ„ ì´ˆê³¼"};
                    if(this.board[c.z][c.y][c.x] !== 0) return {ok:false, msg:"ì´ë¯¸ ë¸”ë¡ ìˆìŒ"};
                }

                if (!isMovement && this.turnCount < 2) {
                     const restricted = ["0,3", "0,4", "1,4", "3,0", "4,0", "4,1"];
                     if (cells.some(c => c.z === 0 && restricted.includes(`${c.x},${c.y}`))) 
                         return {ok:false, msg:"ì´ˆë°˜ ê¸ˆì§€ êµ¬ì—­"};
                }
                
                const groundContacts = cells.filter(c => c.z === 0).length;
                if (groundContacts !== 3 && groundContacts !== 1) 
                    return {ok:false, msg:"ì ‘ì§€ ê·œì¹™ ìœ„ë°˜ (1 or 3)"};

                for(let c of cells) {
                    if(c.z > 0) {
                        const hasSupportBelow = this.board[c.z-1][c.y][c.x] !== 0;
                        const isSelfSupport = cells.some(sc => sc.x===c.x && sc.y===c.y && sc.z===c.z-1);
                        if (!hasSupportBelow && !isSelfSupport) return {ok:false, msg:"ì§€ì§€ëŒ€ í•„ìš”"};
                    }
                }
                return {ok:true, msg:"ê°€ëŠ¥"};
            }

            confirmMove(cells, shapeIdx) {
                // ì‹¤ì œ ì°©ìˆ˜
                if (this.phase === 'PLACEMENT') {
                    this.saveState();
                    this.addBlock(this.currentPlayer, cells, shapeIdx);
                    this.blocksLeft[this.currentPlayer]--;
                } else {
                    this.addBlock(this.currentPlayer, cells, shapeIdx);
                    this.selectedBlock = null;
                    this.selectedBlockOriginalCells = null;
                }
                this.winner = this.checkWin();
                
                if (this.winner === 0) {
                    this.turnCount++;
                    this.currentPlayer = this.currentPlayer===1 ? 2:1;
                    
                    if (this.blocksLeft[1] === 0 && this.blocksLeft[2] === 0) this.phase = 'MOVEMENT';
                    else if (this.blocksLeft[this.currentPlayer] === 0 && this.phase === 'PLACEMENT') this.phase = 'MOVEMENT';

                    // AI Auto Play Check
                    if (this.aiMode && this.currentPlayer === 2) { // AIëŠ” ë°±(2)ìœ¼ë¡œ ê°€ì •
                        triggerAI();
                    }
                }
                return this.winner;
            }

            checkWin() {
                const topMap = Array.from({length: 5}, () => Array(5).fill(0));
                for(let y=0; y<5; y++) {
                    for(let x=0; x<5; x++) {
                        for(let z=4; z>=0; z--) {
                            if(this.board[z][y][x] !== 0) { topMap[y][x] = this.board[z][y][x]; break; }
                        }
                    }
                }
                const dirs = [{dx:1, dy:0}, {dx:0, dy:1}, {dx:1, dy:1}, {dx:1, dy:-1}];
                for(let y=0; y<5; y++) {
                    for(let x=0; x<5; x++) {
                        let color = topMap[y][x];
                        if(color === 0) continue;
                        for(let d of dirs) {
                            let count = 1;
                            for(let k=1; k<5; k++) {
                                let nx = x + d.dx*k; let ny = y + d.dy*k;
                                if(nx>=0 && nx<5 && ny>=0 && ny<5 && topMap[ny][nx]===color) count++; else break;
                            }
                            if(count === 5) return color;
                        }
                    }
                }
                return 0;
            }
        }

        // ==========================================
        // 3. View & Interaction
        // ==========================================
        
        const logic = new GameLogic();
        const mcts = new MCTSEngine();
        const logEl = document.getElementById('log-console');
        const aiLoader = document.getElementById('ai-loader');

        function log(msg) { 
            const div = document.createElement('div'); div.innerText = `> ${msg}`;
            logEl.insertBefore(div, logEl.firstChild);
            if(logEl.children.length > 4) logEl.removeChild(logEl.lastChild);
        }

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xdfe4ea);
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
        camera.position.set(0, 14, 12); camera.lookAt(0,0,0);

        const renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('game-canvas').appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(5,15,5); dirLight.castShadow = true; scene.add(dirLight);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.maxPolarAngle = Math.PI / 2; controls.rotateSpeed = 0.7;

        const boardGroup = new THREE.Group(); scene.add(boardGroup);
        const ghostGroup = new THREE.Group(); scene.add(ghostGroup);
        const hintGroup = new THREE.Group(); scene.add(hintGroup); // íŒíŠ¸ìš©

        const hitPlane = new THREE.Mesh(new THREE.PlaneGeometry(6,6), new THREE.MeshBasicMaterial({ visible: false }));
        hitPlane.material = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.0, side: THREE.DoubleSide, depthWrite: false });
        hitPlane.rotation.x = -Math.PI/2; hitPlane.position.y = 0.5; scene.add(hitPlane);

        scene.add(new THREE.GridHelper(5,5, 0xbdc3c7, 0xecf0f1));
        const basePlate = new THREE.Mesh(new THREE.BoxGeometry(5, 0.1, 5), new THREE.MeshStandardMaterial({color: 0xffffff}));
        basePlate.position.y = -0.05; basePlate.receiveShadow = true; scene.add(basePlate);

        let currentShapeIdx = 0;
        let hoverX = -1, hoverY = -1;
        let hoveredBlockId = null;

        function updateUI() {
            document.getElementById('p1-cnt').innerText = logic.blocksLeft[1];
            document.getElementById('p2-cnt').innerText = logic.blocksLeft[2];
            const pName = logic.currentPlayer===1 ? "(í‘ ì°¨ë¡€)" : "(ë°± ì°¨ë¡€)";
            const pColor = logic.currentPlayer===1 ? "#e74c3c" : "#2ecc71";
            document.getElementById('turn-indicator').innerText = pName;
            document.getElementById('turn-indicator').style.color = pColor;
            
            const badge = document.getElementById('game-phase');
            badge.innerText = logic.phase==='MOVEMENT'?"ì´ë™":"ì°©ìˆ˜";
            badge.style.background = logic.phase==='MOVEMENT'?"#e67e22":"#333";

            // AI Toggle ë²„íŠ¼ ìŠ¤íƒ€ì¼
            const toggleBtn = document.getElementById('btn-ai-toggle');
            if (logic.aiMode) {
                toggleBtn.innerText = "ğŸ¤– AI ëŒ€ì „: ON";
                toggleBtn.classList.add('active');
            } else {
                toggleBtn.innerText = "ğŸ¤– AI ëŒ€ì „: OFF";
                toggleBtn.classList.remove('active');
            }
        }

        function renderBoard() {
            for(let i=boardGroup.children.length-1; i>=0; i--) boardGroup.remove(boardGroup.children[i]);
            const CUBE_SIZE = 0.98;
            const geo = new RoundedBoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE, 4, 0.1);
            
            logic.blocks.forEach(block => {
                const isHovered = (block.id === hoveredBlockId);
                let colorVal = block.player === 1 ? (isHovered ? 0x555555 : 0x333333) : (isHovered ? 0xffffff : 0xeeeeee);
                const mat = new THREE.MeshStandardMaterial({ color: colorVal, roughness: 0.3, emissive: isHovered?0x333333:0x000000 });
                const grp = new THREE.Group();
                grp.userData = { id: block.id, isBlock: true };

                block.cells.forEach(c => {
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(c.x-2, c.z+0.5, c.y-2);
                    mesh.castShadow = true; mesh.receiveShadow = true;
                    mesh.userData = { id: block.id, parentGroup: grp };
                    grp.add(mesh);
                });
                
                // Bridge
                const BRIDGE_THICK = 0.8; 
                for(let i=0; i<block.cells.length; i++) {
                    for(let j=i+1; j<block.cells.length; j++) {
                        const c1 = block.cells[i]; const c2 = block.cells[j];
                        const dist = Math.abs(c1.x-c2.x) + Math.abs(c1.y-c2.y) + Math.abs(c1.z-c2.z);
                        if(dist === 1) {
                            let bg;
                            if (Math.abs(c1.x-c2.x)===1) bg = new THREE.BoxGeometry(1, BRIDGE_THICK, BRIDGE_THICK);
                            else if (Math.abs(c1.y-c2.y)===1) bg = new THREE.BoxGeometry(BRIDGE_THICK, BRIDGE_THICK, 1);
                            else bg = new THREE.BoxGeometry(BRIDGE_THICK, 1, BRIDGE_THICK);
                            const b = new THREE.Mesh(bg, mat);
                            b.position.set((c1.x+c2.x)/2-2, (c1.z+c2.z)/2+0.5, (c1.y+c2.y)/2-2);
                            grp.add(b);
                        }
                    }
                }
                boardGroup.add(grp);
            });
        }

        function updateGhost() {
            while(ghostGroup.children.length > 0) ghostGroup.remove(ghostGroup.children[0]);
            if(logic.winner !== 0) return;
            // íŒíŠ¸ê°€ ë– ìˆìœ¼ë©´ ê³ ìŠ¤íŠ¸ ìˆ¨ê¹€ (ì„ íƒì‚¬í•­)
            // if (hintGroup.children.length > 0) return; 

            if(logic.phase === 'MOVEMENT' && !logic.selectedBlock) return; 
            if(hoverX === -1) return;

            const shape = SHAPES[currentShapeIdx % 8];
            const cells = shape.map(c => ({x:hoverX+c.x, y:hoverY+c.y, z:c.z}));
            const check = logic.checkValidity(logic.currentPlayer, cells, logic.phase==='MOVEMENT');
            const color = check.ok ? 0x2ecc71 : 0xe74c3c;
            drawGhostBlock(cells, color, ghostGroup, 0.6);
        }

        function drawGhostBlock(cells, color, group, opacity) {
            const mat = new THREE.MeshBasicMaterial({color:color, transparent:true, opacity:opacity});
            const geo = new RoundedBoxGeometry(0.96, 0.96, 0.96, 4, 0.1);
            const OFFSET = 0.02;

            cells.forEach(c => {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(c.x-2, c.z+0.5+OFFSET, c.y-2);
                group.add(mesh);
            });
        }

        // --- Interaction ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let downTime = 0;

        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            if (logic.phase === 'MOVEMENT' && !logic.selectedBlock) {
                const intersectsBlock = raycaster.intersectObjects(boardGroup.children, true);
                if (intersectsBlock.length > 0) {
                    const hitObj = intersectsBlock[0].object;
                    const bId = hitObj.userData.id; 
                    if (bId && bId !== hoveredBlockId) { hoveredBlockId = bId; renderBoard(); }
                    hoverX = -1; updateGhost();
                    return; 
                } else if (hoveredBlockId !== null) { hoveredBlockId = null; renderBoard(); }
            }
            const intersects = raycaster.intersectObject(hitPlane);
            if(intersects.length > 0) {
                const p = intersects[0].point;
                const gx = Math.floor(p.x + 2.5); const gy = Math.floor(p.z + 2.5);
                if(gx>=0 && gx<5 && gy>=0 && gy<5) {
                    if(hoverX !== gx || hoverY !== gy) { hoverX = gx; hoverY = gy; updateGhost(); }
                } else { hoverX = -1; updateGhost(); }
            } else { hoverX = -1; updateGhost(); }
        });

        window.addEventListener('mousedown', () => downTime = Date.now());
        window.addEventListener('mouseup', () => { if(Date.now() - downTime < 250) handleClick(); });
        document.getElementById('btn-rotate').addEventListener('click', (e) => { e.stopPropagation(); currentShapeIdx++; updateGhost(); });

        function handleClick() {
            if (logic.winner !== 0) return;
            // íŒíŠ¸ ì‚­ì œ
            while(hintGroup.children.length > 0) hintGroup.remove(hintGroup.children[0]);

            // Movement Pick
            if (logic.phase === 'MOVEMENT' && !logic.selectedBlock) {
                if (hoveredBlockId) {
                    const block = logic.blocks.find(b => b.id === hoveredBlockId);
                    if (block) {
                        const c = block.cells[0];
                        const res = logic.pickBlock(c.x, c.y, c.z);
                        if(res.ok) {
                            log("ì„ íƒë¨. ì´ë™í•  ê³³ í´ë¦­.");
                            currentShapeIdx = res.block.shapeIdx; 
                            hoveredBlockId = null; renderBoard();
                        } else { log(`ğŸš« ${res.msg}`); }
                    }
                }
                return;
            }

            // Place
            if (hoverX !== -1) {
                const shape = SHAPES[currentShapeIdx % 8];
                const cells = shape.map(c => ({x:hoverX+c.x, y:hoverY+c.y, z:c.z}));
                const check = logic.checkValidity(logic.currentPlayer, cells, logic.phase==='MOVEMENT');
                
                if (check.ok) {
                    const win = logic.confirmMove(cells, currentShapeIdx);
                    log(`ì°©ìˆ˜ ì™„ë£Œ`);
                    if (win !== 0) setTimeout(() => alert(`Player ${win} ìŠ¹ë¦¬!`), 100);
                    updateUI(); renderBoard(); updateGhost();
                } else { log(`ğŸš« ${check.msg}`); }
            }
        }

        // --- AI Interface ---
        window.toggleAIMode = () => {
            logic.aiMode = !logic.aiMode;
            updateUI();
            log(`AI ëª¨ë“œ: ${logic.aiMode ? "ON" : "OFF"}`);
            // ì¼œìë§ˆì ë°± ì°¨ë¡€ë¼ë©´ ë°”ë¡œ ë‘ê¸°
            if (logic.aiMode && logic.currentPlayer === 2) triggerAI();
        };

        window.askAI = () => {
            if (logic.winner !== 0) return;
            log("AIê°€ í›ˆìˆ˜ ë‘ëŠ” ì¤‘...");
            aiLoader.style.display = 'block';
            
            setTimeout(() => {
                const bestMove = mcts.getBestMove(logic);
                aiLoader.style.display = 'none';
                
                if (bestMove) {
                    log("ğŸ’¡ AI ì¶”ì²œ ìœ„ì¹˜ í‘œì‹œë¨ (ë…¸ë€ìƒ‰)");
                    // íŒíŠ¸ í‘œì‹œ
                    while(hintGroup.children.length > 0) hintGroup.remove(hintGroup.children[0]);
                    
                    if (bestMove.type === 'place') {
                        drawGhostBlock(bestMove.cells, 0xf1c40f, hintGroup, 0.8);
                    } else {
                        // ì´ë™ì¸ ê²½ìš°
                        drawGhostBlock(bestMove.cells, 0xf1c40f, hintGroup, 0.8);
                        log("âš ï¸ (ì´ë™ í›ˆìˆ˜) í˜„ì¬ ë¸”ë¡ì„ ë“¤ì–´ì„œ ì €ê¸°ë¡œ ì˜®ê¸°ì„¸ìš”.");
                    }
                } else {
                    log("ë‘˜ ìˆ˜ ìˆëŠ” ê³³ì´ ì—†ìŠµë‹ˆë‹¤.");
                }
            }, 100);
        };

        function triggerAI() {
            if (logic.winner !== 0) return;
            aiLoader.style.display = 'block';
            
            setTimeout(() => {
                const bestMove = mcts.getBestMove(logic);
                aiLoader.style.display = 'none';

                if (bestMove) {
                    if (bestMove.type === 'place') {
                        logic.confirmMove(bestMove.cells, bestMove.shapeIdx);
                    } else {
                        // Movement
                        const block = logic.blocks.find(b => b.id === bestMove.fromId);
                        if (block) {
                            // ë¡œì§ìƒ pick -> confirm ê³¼ì • ìˆ˜í–‰
                            logic.saveState();
                            logic.selectedBlockOriginalCells = JSON.parse(JSON.stringify(block.cells));
                            logic.removeBlock(block.id);
                            logic.selectedBlock = block; 
                            // selectedBlockì´ ì„¤ì •ëœ ìƒíƒœì—ì„œ confirmMove í˜¸ì¶œí•˜ë©´ ë¨ (ì½”ë“œ êµ¬ì¡°ìƒ)
                            // í•˜ì§€ë§Œ logic.confirmMoveëŠ” 'í˜„ì¬ ì„ íƒëœ ë¸”ë¡'ì„ ë°°ì¹˜í•¨.
                            // pickBlock í˜¸ì¶œê³¼ ë¹„ìŠ·í•˜ê²Œ ìƒíƒœë¥¼ ë§ì¶°ì¤˜ì•¼ í•¨.
                            logic.confirmMove(bestMove.cells, bestMove.shapeIdx);
                        }
                    }
                    log("ğŸ¤– AI ì°©ìˆ˜ ì™„ë£Œ");
                    if (logic.winner !== 0) setTimeout(() => alert(`Player ${logic.winner} ìŠ¹ë¦¬!`), 100);
                    updateUI(); renderBoard(); updateGhost();
                } else {
                    log("AI ê¸°ê¶Œ (ë‘˜ ê³³ ì—†ìŒ)");
                }
            }, 500); // 0.5ì´ˆ ë”œë ˆì´
        }

        window.undo = () => { 
            if(logic.undo()) { 
                log("ë¬´ë¥´ê¸° ì™„ë£Œ"); 
                hoveredBlockId=null; 
                while(hintGroup.children.length > 0) hintGroup.remove(hintGroup.children[0]);
                renderBoard(); updateUI(); updateGhost(); 
            } 
        };
        window.resetGame = () => { if(confirm("ì´ˆê¸°í™”?")) { logic.reset(); hoveredBlockId=null; while(hintGroup.children.length > 0) hintGroup.remove(hintGroup.children[0]); renderBoard(); updateUI(); log("ì´ˆê¸°í™”ë¨"); } };
        window.addEventListener('keydown', (e) => { 
            if(e.code==='KeyR') { currentShapeIdx++; updateGhost(); } 
            if(e.code==='KeyZ') window.undo(); 
        });
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
        renderBoard(); updateUI(); animate();
    </script>
</body>
</html>